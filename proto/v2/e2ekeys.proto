// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package google.security.e2ekeys.v2;

option java_package = "com.google.security.e2ekeys.v2";
option java_multiple_files = true;
option java_outer_classname = "E2EKeysProto";

import "google/api/annotations.proto";
import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// The E2EKeyService API represents a directory of public keys.
// The key server has the following verifiable security properties:
// - The server keeps a single history of the directory.
// - The server gives consistent answers to queries regardless of audience.
//    - The server publishes a hash of all its data every day.
//    - Users can verify that a given query is contained in that hash.
//    - Only one data item in the server is valid for any particular user.
//
// The API defines the following resource model:
//
// - The API has a collection of [User][google.security.e2ekeys.v2.User]
//   resources named `/users/*`.
//
// - Each User has a collection of
//  [SignedKey][google.security.e2ekeys.v2.SignedKey] resources named by
//  `/users/*/keys/*`
//
service E2EKeyService {
  // GetUser returns a user's keys and a proof that there is only one entry for
  // this user and that it is the same one being provided to everyone else.
  // GetUser also supports querying past values by setting the epoch field.
  rpc GetUser(GetUserRequest) returns (UserProof) {
    option (google.api.http) = { get: "/v2/users/{user_id}" };
  }

  // ListUserHistory returns a list of UserProofs covering a period of time.
  rpc ListUserHistory(ListUserHistoryRequest) returns (ListUserHistoryResponse) {
    option (google.api.http) = { get: "/v2/users/{user_id}/history" };
  }

  // Delete / Create cycles are prohibited for users.
  // Revocations must exist in perpetuity.

  // CreateKey promises to create a new key for a user on the next epoch.
  // Multiple new keys can be created each epoch. Clients must verify that each
  //promise is in-fact in the tree on the next epoch.
  rpc CreateKey (CreateKeyRequest) returns (KeyPromise) {
    option (google.api.http) = {
      post: "/v2/users/{user_id}/keys"
      body: "signed_key"
    };
  }

  // UpdateKey updates a device key.
  rpc UpdateKey (UpdateKeyRequest) returns (KeyPromise) {
    option (google.api.http) = {
      put: "/v2/users/{user_id}/keys/{key_id}"
      body: "signed_key"
    };
  }

  // DeleteKey deletes a key. Returns NOT_FOUND if the key does not exist.
  rpc DeleteKey(DeleteKeyRequest) returns (protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v2/users/{user_id}/keys/{key_id}"
    };
  }
}

// A User entry along with its proof.
message UserProof {
  // The user object
  User user = 1;
  // The authentication path to the epoch root.
  Proof proof = 2;
  // promises is a list of keys that the server has accepted, but hasn't merged
  // into the Merkle tree yet.
  repeated KeyPromise promises = 4;
}

// The User is the leaf object in the binary Merkle Tree. Its unique location
// in the tree is identified by a hash of an unpredictable verifiable function
// The value of the user leaf node is
// HMAC(nonce, (H(Meta) || H(k1) || H(k2) ... || H(kn))
message User {
  // Metadata associated with this user.
  UserMeta meta = 1;
  // keys is an ordered array of SignedKeys for this user.
  // When filtering key results, individual SignedKeys may be empty, but the
  // associated hash will remain in key_ides.
  repeated SignedKey signed_keys = 2;
  // key_ides is an ordered array of hashes of SignedKeys for this user.
  repeated bytes signed_key_ides = 3;
  // Nonce prevents an adversary from brute forcing nodes to the side of a user.
  bytes nonce = 4;
}

// Meta is a container for user metadata.
message UserMeta {
  // reset_count is a monotonically increasing number representing the number
  // of times this account has been reset. A change in this number generates
  // a warning the next time a client attempts to message this user.
  uint32 reset_count = 1;

  // Rotation policy:
  // Account reset generates warning.
  // All other actions require signature from key in previous epoch.

  // Placeholder for additional provider specific metadata.
  google.protobuf.Any provider_metadata = 2;
}

// SignedKey contains a Key and associated signatures, showing continuity of
// key ownership.
message SignedKey{
  // A key with metadata.
  Key key = 1;

  // A key with metadata.
  message Key {
    // The name of the application this key is for.
    string app_id = 1;
    // A device identifier. Used to show a user what devices have public keys
    // associated with them.
    string device_id = 3; // Private. Empty in GET requests and Merkle Tree.
    // The encryption key itself in any format the application prefers.
    bytes key = 4;
    // Format for the key.
    Format key_format = 5;
    // Key Formats.
    enum Format {
      // Unknown key format.
      UNKNOWN = 0;
      // Eliptic Curve Public Key.
      ECC = 1;
      // Ascii armored PGP public key, beginning with
      //-----BEGIN PGP PUBLIC KEY BLOCK-----
      PGP_KEYRING = 2;
    }
    // Timestamp of when this key was added.  Verified by server.
    google.protobuf.Timestamp creation_time = 6;

    // When a user wishes to revoke a key that has been compromised, rotate
    // forward to a new key.  Old keys are automatically considered revoked.
    //
    // When a user wishes to revoke a key due to a lost device, delete the key.
    // Keys signed with the revoked key will still be valid, but no new devices
    // may be added with the revoked key.
  }
  // Signature of key, by the current key. Proves ownership of new key.
  Signature signature_current = 2;
  // Signature of key, by either: 1) the same key in the previous epoch, proving
  // that the correct owner of the key is making the rotation or 2) a different
  // key in the previous epoch, proving that the owner of the accout is adding
  // the new device.
  Signature signature_old = 3;
  // key_id is the PGP fingerprint, or for ecc, the hash of the ecc key.
  // Used to uniquely identify the key.
  // (-- This field should either be a hash of the key, or a signed element --)
  string key_id = 4;
}

// Signature represents a digital signature of the hash of an object.
message Signature {
  // Hash of the key used for signing.
  string key_id = 1;
  // Algorithms used for hashing and signing.
  Scheme scheme = 2;
  // Algorithm options for hashing and signing.
  enum Scheme {
    // Elliptic curve digital signature on data hashed with SHA256.
    ECDSA_SHA256 = 0;
  }
  // The serialized signature.
  bytes signature = 3;
}

// A key object, paired with a timestamp.
message SignedKeyTimestamp {
  // The time this object was created.
  google.protobuf.Timestamp creation_time = 1;
  // The signed new key.
  SignedKey signed_key = 2;
  // The user this key is for.
  string user_id = 3;
  // The location in the Merkle tree for this user.
  bytes vuf = 4;
}

// A promise to include a given key in the merkle tree on the next epoch.
message KeyPromise {
  // The device and timestamp.
  SignedKeyTimestamp signed_key_timestamp = 1;
  // A signature over the device and timestamp.
  Signature signature = 2;
}

// A Proof provides an authentication path through the Merkle Tree that
// proves that an item is or is not present in the tree.
message Proof {
  // Neighbors is a list of all the adacent nodes along the path from the
  // bottommost node to the root. To save space, hashes for empty subtrees are
  // nil, and the number of hashes is equal to the length of the longest common
  // prefix with another entry in the tree (since a leaf node is moved up to
  // that point -- subtrees with a single entry are coalesced into a single
  // node).
  repeated bytes neighbors = 1;
  // The root node in the Merkle tree.
  SignedRoot epoch = 3;
  // Output of an verifiable unpredictable function on user.meta.user_id.
  // Prevents an adversary from brute forcing a user's location in the Merkle
  // tree.
  bytes vuf = 4;
  // This is the VUF for the binding that does exist; it will share a prefix
  // with vuf, but in case the leaf contains the wrong contents, it will be
  // different. It will be nil if the requested VUF falls under an empty branch.
  bytes existingVuf = 5;
  // This is the commitment for the binding that does exist. If the leaf
  // contains the wrong contents, the client can use this to verify that it in
  // fact is at that position in the tree.
  bytes existingCommitment = 6;
}

// SignedRoot represents a signed state of the Merkel tree.
message SignedRoot {
  // Signature of this epoch's hash.
  Signature epoch_sig = 1;
  // This epoch's hash.
  bytes epoch_hash = 2;
  // Value of this epoch.
  Epoch epoch = 3;
}

// Epoch corresponds to the signed contents of a signed tree root, containing
// the epoch's timestamp, number, root node hash, and previous epoch hash.
message Epoch {
  // The timestamp of the current epoch.
  google.protobuf.Timestamp current_time = 1;
  // The first epoch has epoch_nr 1, and the numbers count up sequentially.
  int64 epoch_nr = 2;
  // Hash of previous epoch.
  bytes previous_epoch = 3;
  // Hash of the root in the tree.
  bytes root_node_hash = 4;
}


// Get request for a user object.
message GetUserRequest {
  // Absence of the time field indicates a request for the current value.
  google.protobuf.Timestamp time = 1;
  // User identifier. Most commonly an email address.
  string user_id = 2;
  // Only return the keys belonging to this app.
  string app_id = 3;
}

// Get a list of historical values for a user.
message ListUserHistoryRequest {
  // The user identifier.
  string user_id = 1;
  // The time at which to start pagination.
  google.protobuf.Timestamp starting_time = 2;
  // The maximum number of entries to return.
  int32 page_size = 4;
}

// A paginated history of values for a user.
message ListUserHistoryResponse {
  // The list of values this user_id has contained over time.
  repeated UserProof values = 1;
  // The next time to query for pagination.
  google.protobuf.Timestamp next_time = 2;
}

// Create a new device.
message CreateKeyRequest {
  // The User to requset for.
  string user_id = 1;
  // The new key.
  SignedKey signed_key = 2;
}

// Update a device.
message UpdateKeyRequest {
  // The User to update.
  string user_id = 2;
  // The key to update.
  string key_id = 4;
  // The new value of the device.
  SignedKey signed_key = 5;
}

// Delete a key.
message DeleteKeyRequest {
  // The User to update.
  string user_id = 2;
  // The key to delete.
  string key_id = 4;
}
