// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package end2end;
import "google/protobuf/timestamp.proto";

// The Keyserver API represents a directory of public keys.
// The key server has the following verifiable security properties:
// - The server keeps a single history of the directory.
// - The server gives consistent answers to queries regardless of audience.
//    - The server publishes a signed epoch head (SEH) of all its data every
//      epoch.
//    - Users can verify that a given entry is contained in that SEH.
//    - Only one entry in the server is valid for any particular user id.
//
// The API defines the following resource model:
//
// - The API has a collection of
//   [EntryProfileAndProof][google.security.e2ekeys.v2.EntryProfileAndProof]
//   resources named `/users/*`.
//
// - Each User has a collection of [Key][google.security.e2ekeys.v2.Key] 
//   resources named by `/users/*/keys/*`.
//
service Keyserver {
  // GetProfile returns a user's profile, the comittment in the merkle tree, a
  // proof that there is only one entry for this user, and a proof that it is
  // the same data being provided to everyone else.
  // GetProfile also supports querying past values by setting the epoch field.
  rpc GetProfile(GetProfileRequest) returns (GetProfileResponse);

  // PutProfileRequest updates a user's profile if sufficient authentication
  // is provided. A lookup of the freshly updated profile is returned.
  rpc PutProfile(PutProfileRequest) returns (GetProfileResponse);
}

//
// Data types.
//

// SignedEpochHead represents a signed state of the Merkel tree.
message SignedEpochHead {
  // Serialized TimestampedEpochHead.
  bytes head = 1;
  // Signature of head, using the signature type of the key.
  // keyed by the first 64 bits bytes of the hash of the key (little-endian).
  map<fixed64,bytes> signatures = 2;
}

message TimestampedEpochHead {
  EpochHead head = 1;
  // The timestamp of this signature.
  google.protobuf.Timestamp signing_time = 2;
}

// EpochHead is the head node of the Merkle Tree as well as additional metadata 
// for the tree.
message EpochHead {
  // realm is the domain...
  string realm = 1;
  // epoch number
  uint64 epoch = 2;
  // The value of the root node of the merkle tree.
  bytes root_hash = 3;
  // IssueTime is the time when this epoch was released. All epochs for the
  // same keyserver MUST have non-decreasing IssueTimes.
  google.protobuf.Timestamp issue_time = 4;
  // Hash of previous SEH. 64 bytes of SHA3-SHAKE256.
  bytes previous_epoch_head_hash = 5;
}

message GetProfileResponse {
  // user_id supports sending this as a complete proof to a third party. 
  // user_id is not required to be filled by the server.
  string user_id = 1;
  // index_proof is the proof portion the unpredictable verifiable function on
  // user_id. If H(index_signature) != entry.index, but they share a common
  // prefix of len(merkle_tree_neighbors), this GetProfileResponse is a proof
  // of non-existance for user_id.
  bytes index_proof = 2;
  // The signed epoch head.  A server may choose to return multiple signatures
  // of the same head for the same epoch. A client MUST NOT consider the
  // presence of surplus or invalid epoch heads in this field an error.
  repeated SignedEpochHead signed_epoch_heads = 3;
  // tree_proof is a list of all the adjacent nodes along the path
  // from the bottommost node to the head.
  TreeProof tree_proof = 4;
  // Entry contains the public portion of the user's data, and a comitment to
  // profile.
  bytes entry = 5;
  // Profile contains the user's keys.
  bytes profile = 6;
}

// A Proof provides an authentication path through the Merkle Tree that proves
// that an item is or is not present in the tree. All hashes are SHA3-SHAKE256
// with 32 bytes of output.
message TreeProof {
  // Neighbors is a list of all the adjacent nodes along the path from the
  // bottommost node to the root. To save space, hashes for empty subtrees are
  // nil, and the number of hashes is equal to the length of the longest common
  // prefix with another entry in the tree (since a leaf node is moved up to
  // that point -- subtrees with a single entry are coalesced into a single
  // node).
  repeated bytes neighbors = 1;
  // This is the index for the binding that does exist; it will share a prefix
  // with the requested index, but in case the leaf contains the wrong
  // contents, it will be different. It will be nil if the requested VRF falls
  // under an empty branch.
  bytes existing_index = 2;
  // This is the hash of the entry for the binding that does exist. If the leaf
  // contains the wrong contents, the client can use this to verify that the
  // incorrect leaf takes up the entire branch.
  bytes existing_entry_hash = 3;
}

// Step is a combined, ordered list of SignedEntryUpdates and SignedEpochHeads
// which are made available to verifiers.
// TODO: see coname VerifierStep
// message Step {
//   oneof type {
//     // entry_changed contains a serialized SignedEntryUpdate.
//     bytes entry_changed = 1;
//     SignedEpochHead seh = 2;
//   }
//   // epoch of this udpate.
//   uint64 epoch = 3;
//   // commitment_timestamp is the ordered commitment_timestamp of this step.
//   uint64 commitment_timestamp = 4;
// }

// EntryUpdate is the proto a client sends to update their profile.
message PutProfileRequest {
  // UserID specifies the id for the new account to be registered. Updates to
  // an existing profile do NOT require an UserID.
  string user_id = 1;
  SignedEntryUpdate update = 2;
  // profile is the serialized protobuf Profile.
  // profile is private and must not be released to verifiers.
  bytes profile = 3;
  // GetProfileRequest specifies the profile lookup to be returned to the user
  // after this update has been committed and applied to the keyserver state.
  // It is used by the client library to cryptographically verify that an
  // update indeed went through.
  GetProfileRequest get_profile_request = 4;

  // DkimProof is used in Coname to vouch for the validity of a new
  // registration.
  bytes dkim_proof = 1001;
}

// SignedEntryUpdate is what users provide to update their profiles.
// A serialized SignedEntryUpdate is used as the leaf value in the MerkleTree.
message SignedEntryUpdate {
  // new_entry is the serialized protobuf Entry.
  bytes new_entry = 1;
  // Signature of entry, by the entry_key inside entry AND the old key from the
  // previous epoch. The first proves ownership of new epoch key, and the
  // second proves the the correct owner is making this change.
  map<fixed64,bytes> signatures = 2;
}

// Entry is the leaf node object for the Merkle Tree. Its unique index in the
// tree is identified by a hash of an verifiable unpredictable function on the
// user_id.
message Entry {
  // index is the location in the merkle tree for this entry.
  // If signing keys are not unique per user, we need to tie updates to a
  // particular profile.
  bytes index = 1;
  // version prevents replaying old signed EntryUpdates.
  // not nessesarilly incremented by only one each update.
  uint64 version = 2;
  // UpdatePolicy will be used to verify SignedEntryUpdates to this
  // entry. It is NOT used for encryption, and SHOULD be ignored by
  // applications that do not intend to manage the user's profile. It has
  // also been called "the public key of the profile signing key" or "the
  // public identity key". A keyserver MUST NOT discriminate users based on
  // ther structure of their update_key other than (1) as specified in
  // SignedEntryUpdate and (2) common-sense limits on the total size of an
  // entry to limit storage cost.
  AuthorizationPolicy update_policy = 3;
  // profile_commitment is a cryptographic commitment to the Profile,
  // Instantiated as SHA3SHAKE256 of the profile (which contains a nonce).
  bytes profile_commitment = 4;
}

// Profile contains data hidden behind the crypto comitment.
message Profile {
  // Nonce is used to prevent guessing of profile contents. Clients SHOULD use
  // 16 random bytes.
  bytes nonce = 1;
  // key_list is an appId and key map.
  map<string,bytes> keys = 2;
}

// PublicKey defines a key used for verifying signatures in the keyserver
// ecosystem.
message PublicKey {
  // KeyFormats from Keyczar.
  oneof key_type {
    bytes ed25519 = 1; // 32 bytes (<http://ed25519.cr.yp.to/>)
    bytes rsa_verifying_sha256_2048 = 2;
    bytes ecdsa_verifying_p256 = 3;
  }
}

// AuthorizationPolicy is used to check whether some signatures make up
// sufficient authorization to back an action.
// This is used to implement the following:
// 1. Account Recovery through service provider: if an user's entry has the
// update key set to threshold(1,user,serviceprovider), the service
// provider can perform account recovery. Note that a third party will not
// necessarily know who the subkeys are held by. Thus, the client
// implementation MUST require a signed certificate confirming possession
// of the secret key and promising to do no evil from every trustee whose
// key is used for recovery in this manner.
// 2. Service providers with servers in geographically diverse locations
// can use a threshold to limit the damage the compromise or loss of one
// replica can do. Example threshold(2,freedonia,gilead,mordor).
// 3. Adaptive key rollover during cryptocalypse.
message AuthorizationPolicy {
	map <fixed64, PublicKey> public_keys = 1;
	oneof policy_type {
		QuorumExpr quorum = 2;
	}
}

// QuorumExpr represents a function with type set<uint64> -> bool. An
// expression evaluates to true given args iff the sum of the following two
// numbers is at least threshold:
// - number of entries in verifiers that are in args
// - number of subexpressions that evaluate to true
// note: expr.eval(a) \wedge expr.eval(b) -> expr.eval(a \cup b)
message QuorumExpr {
	uint32 threshold = 1; // required
	repeated fixed64 candidates = 2;
	// QuorumExpr allows expressing contitions of the form "two out of these
	// and three out of those".
	// If an implementation chooses to ban recursive thresholding, it can do so
	// ignoring this field. However, doing so is NOT SUPPORTED.
	repeated QuorumExpr subexpressions = 3;
}

//
// RPC request/response messages.
//

// Get request for a user object.
message GetProfileRequest {
  // Absence of the time field indicates a request for the current value.
  uint64 epoch = 1;
  // User identifier. Most commonly an email address.
  string user_id = 2;
  // QuorumRequirement specifies which verifiers must have ratified the result
  // for it to be accepted. A server SHOULD fall back to an older directory
  // state if the signatures of the latest one do not satisfy the quorum
  // requirement, and MAY return only signatures from public keys listed in
  // QuorumRequirement.
  QuorumExpr quorum_requirement = 3;
  // TODO(cesarghali): implement app_id filtering.
  // Only return the keys belonging to this app.
  // string app_id = 4;
}
