// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package google.security.e2ekeys.v2;

option java_package = "com.google.security.e2ekeys.v2";
option java_multiple_files = true;
option java_outer_classname = "E2EKeysProto";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// The E2EKeyService API represents a directory of public keys.
// The key server has the following verifiable security properties:
// - The server keeps a single history of the directory.
// - The server gives consistent answers to queries regardless of audience.
//    - The server publishes a signed epoch head (SEH) of all its data every
//      epoch.
//    - Users can verify that a given entry is contained in that SEH.
//    - Only one entry in the server is valid for any particular user id.
//
// The API defines the following resource model:
//
// - The API has a collection of
//   [EntryProfileAndProof][google.security.e2ekeys.v2.EntryProfileAndProof]
//   resources named `/users/*`.
//
// - Each User has a collection of [Key][google.security.e2ekeys.v2.Key] 
//   resources named by `/users/*/keys/*`.
//
service E2EKeyService {
  // GetUser returns a user's profile, the comittment in the merkle tree, a
  // proof that there is only one entry for this user, and a proof that it is
  // the same data being provided to everyone else.
  // GetUser also supports querying past values by setting the epoch field.
  rpc GetUser(GetUserRequest) returns (EntryProfileAndProof);

  // ListUserHistory returns a list of UserProofs covering a period of time.
  rpc ListUserHistory(ListUserHistoryRequest) returns (ListUserHistoryResponse);

  // blocking or polling?
  rpc UpdateUser(UpdateUserRequest) returns (protobuf.Empty);

  // List the Signed Epoch Heads, from epoch to epoch.
  rpc ListSEH(ListSEHRequest) returns (ListSEHResponse);

  // List the EntryUpdates by update number.
  rpc ListUpdate(ListUpdateRequest) returns (ListUpdateResponse);

  // ListSteps combines SEH and EntryUpdates into single list.
  rpc ListSteps(ListStepsRequest) returns (ListStepsResponse);
}

//
// Data types.
//

// SignedEpochHead represents a signed state of the Merkel tree.
message SignedEpochHead {
  // Signature of this epoch's hash, using the signature type of the key.
  bytes head_sig = 1;
  // Serialized TimestampedEpochHead.
  bytes head = 2;
  // key_hash is the first 4 bytes of the SHA256 hash of the key used for
  // signing. May be used for key rotation and/or multiple signatures.
  uint64 key_hash = 3;
}

message TimestampedEpochHead {
  EpochHead head = 1;
  // The timestamp of this signature.
  google.protobuf.Timestamp current_time = 2;
}

// EpochHead is the head node of the Merkle Tree as well as additional metadata 
// for the tree.
message EpochHead {
  // epoch number
  uint64 epoch = 1;
  // Hash of previous SEH.
  bytes previous_seh = 3;
  // The value of the head node of the merkle tree.
  bytes head = 4;
  // realm is the domain...
  string realm = 5;
}

message UVF {
  //TODO: fill with data needed for to verify the Unpredictable Verifiable
  //Function.
  bytes vrf = 1;
}

message EntryProfileAndProof {
  // Entry contains the public portion of the user's data, and a comitment to
  // profile.
  Entry entry = 1;
  // Profile contains the user's keys.
  bytes profile = 2;
  // merkle_tree_neighbors is a list of all the adjacent nodes along the path
  // from the bottommost node to the head.
  repeated bytes merkle_tree_neighbors = 3;
  // The signed epoch head.  A server may choose to return multiple signatures
  // of the same head for the same epoch.
  repeated SignedEpochHead seh = 4;
  // index_signature is the signed portion the unpredictable verifiable
  // function on user_id. If H(index_signature) != entry.index, but they share
  // a common prefix of len(merkle_tree_neighbors), this is a proof of
  // non-existance for user_id.
  UVF index_signature = 5;
  // user_id supports sending this as a complete proof to a third party. 
  // user_id is not filled by the server.
  string user_id = 6;
}

// Step is a combined, ordered list of SignedEntryUpdates and SignedEpochHeads
// which are made available to verifiers.
message Step {
  oneof type {
    // entry_changed contains a serialized SignedEntryUpdate.
    bytes entry_changed = 1;
    SignedEpochHead seh = 2;
  }
  // epoch of this udpate.
  uint64 epoch = 3;
  // sequence is the ordered sequence number of this step.
  // Equal to epoch_num + update sequence number.
  uint64 sequence = 4;
}

// EntryUpdate is the proto a client sends to update their profile.
message EntryUpdateRequest {
  // signed_update contains a serialized SignedEntryUpdate and authorizes the
  // change to profile.
  bytes signed_entry_update = 1;
  // profile is the serialized protobuf Profile.
  // profile is private and must not be released to verifiers.
  bytes profile = 2;
  // profile_nonce is at least 16 random bytes.
  bytes profile_nonce = 3;
}

message SignedEntryUpdate {
  // Signature of entry, by the entry_key inside entry.
  // Proves ownership of new key.
  map<uint64, bytes> signature_new = 1;
  // Signature of entry, by the entry_key from the previous epoch.
  // Proves the the correct owner is making this change.
  map<uint64, bytes> signature_old = 2;
  // entry is the serialized protobuf Entry.
  bytes entry = 3;
}

// Entry is the leaf node object for the Merkle Tree. Its unique index in the
// tree is identified by a hash of an verifiable unpredictable function on the
// user_id.
message Entry {
  // entry_key allows verifiers to validate updates to Entry.
  // entry_key is a ECDSH key.
  bytes entry_key = 1;
  // profile_commitment is a cryptographic commitment to the Profile of the form
  // HMAC(profile_nonce, serialized_profile)
  bytes profile_commitment = 2;
  // update_count prevents replaying old signed EntryUpdates.
  // not nessesarilly incremented by only one each update.
  uint64 update_count = 3;
  // index is the location in the merkle tree for this entry.
  // If signing keys are not unique per user, we need to tie updates to a
  // particular profile.
  bytes index = 4;
}

// Profile contains data hidden behind the crypto comitment.
message Profile {
  // key_list is an appId and key map.
  map<string, bytes> keys = 2;
}

// PublicKey defines a key this domain uses to sign EpochHeads with.
message PublicKey {
  bytes key = 1;

  // KeyFormats from Keyczar.
  enum KeyFormat {
    UNKNOWN = 0;
    PUBLIC_DSA_2048 = 1;
    RSA_VERIFYING_SHA256_2048 = 2;
    ECDSA_VERIFYING_P256 = 3;  // NIST_P256
  }

  KeyFormat format = 2;
  // ower_id is the unique string of a particular replica.
  string owner_id = 3;
}

//
// RPC request/response messages.
//

// Get request for a user object.
message GetUserRequest {
  // Absence of the time field indicates a request for the current value.
  uint64 epoch = 1;
  // User identifier. Most commonly an email address.
  string user_id = 2;
  // TODO(cesarghali): implement app_id filtering.
  // Only return the keys belonging to this app.
  string app_id = 3;
  // TODO: implement key_hash filtering.
  // Only return SEH's that are signed by these keys.
  repeated uint64 trusted_keys = 4;
}

// Get a list of historical values for a user.
message ListUserHistoryRequest {
  // The user identifier.
  string user_id = 1;
  // from_epoch is the starting epcoh.
  uint64 start_epoch = 2;
  // The maximum number of entries to return.
  int32 page_size = 3;
  // compression_mode allows a user to verify thier own entries.
  // TODO: optional compression mode?
}

// A paginated history of values for a user.
message ListUserHistoryResponse {
  // The list of values this user_id has contained over time.
  repeated EntryProfileAndProof values = 1;
  // The next time to query for pagination.
  uint64 next_epoch = 2;
}

// Update a user's profile.
message UpdateUserRequest {
  // The User to update.
  string user_id = 1;
  // The new value of the key.
  EntryUpdateRequest update = 2;
}

message ListSEHRequest {
  // from_epoch is the starting epcoh.
  uint64 start_epoch = 1;
  // The maximum number of entries to return.
  int32 page_size = 2;
}

message ListSEHResponse {
  repeated SignedEpochHead heads = 1;
}

message ListUpdateRequest {
  // start_sequence is the starting sequence number.
  uint64 start_sequence = 1;
  // The maximum number of entries to return.
  int32 page_size = 2;
}

message ListUpdateResponse {
  // updates contains serialized SignedEntryUpdate.
  repeated bytes updates = 1;
}

message ListStepsRequest {
  // start_sequence is the starting sequence number.
  uint64 start_sequence = 1;
  // The maximum number of entries to return.
  int32 page_size = 2;
}

message ListStepsResponse {
  repeated Step steps = 1;
}
