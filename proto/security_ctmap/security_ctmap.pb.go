// Code generated by protoc-gen-go.
// source: proto/security_ctmap/security_ctmap.proto
// DO NOT EDIT!

/*
Package security_ctmap is a generated protocol buffer package.

It is generated from these files:
	proto/security_ctmap/security_ctmap.proto

It has these top-level messages:
	EpochHead
	SignedEpochHead
	GetLeafRequest
	GetLeafResponse
	UpdateLeafRequest
	UpdateLeafResponse
	MutationEntry
*/
package security_ctmap

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import security_protobuf "github.com/google/e2e-key-server/proto/security_protobuf"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// EpochHead is the head node of the Merkle Tree as well as additional metadata
// for the tree.
type EpochHead struct {
	// realm is the domain identifier for the transparent map.
	Realm string `protobuf:"bytes,1,opt,name=realm" json:"realm,omitempty"`
	// epoch number
	Epoch int64 `protobuf:"varint,2,opt,name=epoch" json:"epoch,omitempty"`
	// root is the value of the root node of the merkle tree.
	Root []byte `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	// issue_time is the time when this epoch was released. Monotonically increasing.
	IssueTime *security_protobuf.Timestamp `protobuf:"bytes,4,opt,name=issue_time" json:"issue_time,omitempty"`
}

func (m *EpochHead) Reset()                    { *m = EpochHead{} }
func (m *EpochHead) String() string            { return proto.CompactTextString(m) }
func (*EpochHead) ProtoMessage()               {}
func (*EpochHead) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EpochHead) GetIssueTime() *security_protobuf.Timestamp {
	if m != nil {
		return m.IssueTime
	}
	return nil
}

// SignedEpochHead represents a signed state of the Merkel tree.
type SignedEpochHead struct {
	// Serialized EpochHead.
	EpochHead []byte `protobuf:"bytes,1,opt,name=epoch_head,proto3" json:"epoch_head,omitempty"`
	// Signature of head, using the signature type of the key.
	// keyed by the first 64 bits bytes of the hash of the key.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEpochHead) Reset()                    { *m = SignedEpochHead{} }
func (m *SignedEpochHead) String() string            { return proto.CompactTextString(m) }
func (*SignedEpochHead) ProtoMessage()               {}
func (*SignedEpochHead) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SignedEpochHead) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// GetLeafRequest for a verifiable map leaf.
type GetLeafRequest struct {
	Index []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch" json:"epoch,omitempty"`
}

func (m *GetLeafRequest) Reset()                    { *m = GetLeafRequest{} }
func (m *GetLeafRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeafRequest) ProtoMessage()               {}
func (*GetLeafRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// GetLeafResponse for a verifiable map leaf.
type GetLeafResponse struct {
	LeafData []byte `protobuf:"bytes,1,opt,name=leaf_data,proto3" json:"leaf_data,omitempty"`
	// neighbors is a list of all the adjacent nodes along the path
	// from the bottommost node to the head.
	Neighbors [][]byte `protobuf:"bytes,2,rep,name=neighbors,proto3" json:"neighbors,omitempty"`
}

func (m *GetLeafResponse) Reset()                    { *m = GetLeafResponse{} }
func (m *GetLeafResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLeafResponse) ProtoMessage()               {}
func (*GetLeafResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// UpdateLeafRequest submits a change for the value at index.
type UpdateLeafRequest struct {
	Index    []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	Mutation []byte `protobuf:"bytes,2,opt,name=mutation,proto3" json:"mutation,omitempty"`
}

func (m *UpdateLeafRequest) Reset()                    { *m = UpdateLeafRequest{} }
func (m *UpdateLeafRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateLeafRequest) ProtoMessage()               {}
func (*UpdateLeafRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// UpdateLeafResponse returns the current value of index.
type UpdateLeafResponse struct {
	Proof *GetLeafResponse `protobuf:"bytes,1,opt,name=proof" json:"proof,omitempty"`
}

func (m *UpdateLeafResponse) Reset()                    { *m = UpdateLeafResponse{} }
func (m *UpdateLeafResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateLeafResponse) ProtoMessage()               {}
func (*UpdateLeafResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UpdateLeafResponse) GetProof() *GetLeafResponse {
	if m != nil {
		return m.Proof
	}
	return nil
}

// MutationEntry is either a mutation or an epoch advancement.
type MutationEntry struct {
	// Types that are valid to be assigned to Type:
	//	*MutationEntry_Update
	//	*MutationEntry_AdvanceEpoch
	Type isMutationEntry_Type `protobuf_oneof:"type"`
}

func (m *MutationEntry) Reset()                    { *m = MutationEntry{} }
func (m *MutationEntry) String() string            { return proto.CompactTextString(m) }
func (*MutationEntry) ProtoMessage()               {}
func (*MutationEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isMutationEntry_Type interface {
	isMutationEntry_Type()
}

type MutationEntry_Update struct {
	Update *UpdateLeafRequest `protobuf:"bytes,1,opt,name=update,oneof"`
}
type MutationEntry_AdvanceEpoch struct {
	AdvanceEpoch bool `protobuf:"varint,2,opt,name=advance_epoch,oneof"`
}

func (*MutationEntry_Update) isMutationEntry_Type()       {}
func (*MutationEntry_AdvanceEpoch) isMutationEntry_Type() {}

func (m *MutationEntry) GetType() isMutationEntry_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *MutationEntry) GetUpdate() *UpdateLeafRequest {
	if x, ok := m.GetType().(*MutationEntry_Update); ok {
		return x.Update
	}
	return nil
}

func (m *MutationEntry) GetAdvanceEpoch() bool {
	if x, ok := m.GetType().(*MutationEntry_AdvanceEpoch); ok {
		return x.AdvanceEpoch
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MutationEntry) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MutationEntry_OneofMarshaler, _MutationEntry_OneofUnmarshaler, _MutationEntry_OneofSizer, []interface{}{
		(*MutationEntry_Update)(nil),
		(*MutationEntry_AdvanceEpoch)(nil),
	}
}

func _MutationEntry_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MutationEntry)
	// type
	switch x := m.Type.(type) {
	case *MutationEntry_Update:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Update); err != nil {
			return err
		}
	case *MutationEntry_AdvanceEpoch:
		t := uint64(0)
		if x.AdvanceEpoch {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("MutationEntry.Type has unexpected type %T", x)
	}
	return nil
}

func _MutationEntry_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MutationEntry)
	switch tag {
	case 1: // type.update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UpdateLeafRequest)
		err := b.DecodeMessage(msg)
		m.Type = &MutationEntry_Update{msg}
		return true, err
	case 2: // type.advance_epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &MutationEntry_AdvanceEpoch{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _MutationEntry_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MutationEntry)
	// type
	switch x := m.Type.(type) {
	case *MutationEntry_Update:
		s := proto.Size(x.Update)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MutationEntry_AdvanceEpoch:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*EpochHead)(nil), "security_ctmap.EpochHead")
	proto.RegisterType((*SignedEpochHead)(nil), "security_ctmap.SignedEpochHead")
	proto.RegisterType((*GetLeafRequest)(nil), "security_ctmap.GetLeafRequest")
	proto.RegisterType((*GetLeafResponse)(nil), "security_ctmap.GetLeafResponse")
	proto.RegisterType((*UpdateLeafRequest)(nil), "security_ctmap.UpdateLeafRequest")
	proto.RegisterType((*UpdateLeafResponse)(nil), "security_ctmap.UpdateLeafResponse")
	proto.RegisterType((*MutationEntry)(nil), "security_ctmap.MutationEntry")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for VerifiableMapService service

type VerifiableMapServiceClient interface {
	// GetLeaf retrieves the value stored at a particular index.
	GetLeaf(ctx context.Context, in *GetLeafRequest, opts ...grpc.CallOption) (*GetLeafResponse, error)
	// UpdateLeaf submits a change to the value at index. Clients retry until
	// change is visble in GetLeafResponse.
	UpdateLeaf(ctx context.Context, in *UpdateLeafRequest, opts ...grpc.CallOption) (*GetLeafResponse, error)
}

type verifiableMapServiceClient struct {
	cc *grpc.ClientConn
}

func NewVerifiableMapServiceClient(cc *grpc.ClientConn) VerifiableMapServiceClient {
	return &verifiableMapServiceClient{cc}
}

func (c *verifiableMapServiceClient) GetLeaf(ctx context.Context, in *GetLeafRequest, opts ...grpc.CallOption) (*GetLeafResponse, error) {
	out := new(GetLeafResponse)
	err := grpc.Invoke(ctx, "/security_ctmap.VerifiableMapService/GetLeaf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableMapServiceClient) UpdateLeaf(ctx context.Context, in *UpdateLeafRequest, opts ...grpc.CallOption) (*GetLeafResponse, error) {
	out := new(GetLeafResponse)
	err := grpc.Invoke(ctx, "/security_ctmap.VerifiableMapService/UpdateLeaf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VerifiableMapService service

type VerifiableMapServiceServer interface {
	// GetLeaf retrieves the value stored at a particular index.
	GetLeaf(context.Context, *GetLeafRequest) (*GetLeafResponse, error)
	// UpdateLeaf submits a change to the value at index. Clients retry until
	// change is visble in GetLeafResponse.
	UpdateLeaf(context.Context, *UpdateLeafRequest) (*GetLeafResponse, error)
}

func RegisterVerifiableMapServiceServer(s *grpc.Server, srv VerifiableMapServiceServer) {
	s.RegisterService(&_VerifiableMapService_serviceDesc, srv)
}

func _VerifiableMapService_GetLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableMapServiceServer).GetLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security_ctmap.VerifiableMapService/GetLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableMapServiceServer).GetLeaf(ctx, req.(*GetLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableMapService_UpdateLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableMapServiceServer).UpdateLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security_ctmap.VerifiableMapService/UpdateLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableMapServiceServer).UpdateLeaf(ctx, req.(*UpdateLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VerifiableMapService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "security_ctmap.VerifiableMapService",
	HandlerType: (*VerifiableMapServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLeaf",
			Handler:    _VerifiableMapService_GetLeaf_Handler,
		},
		{
			MethodName: "UpdateLeaf",
			Handler:    _VerifiableMapService_UpdateLeaf_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 461 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x92, 0xcd, 0x6e, 0xd3, 0x40,
	0x14, 0x85, 0xeb, 0x26, 0x0d, 0xcd, 0x8d, 0xd3, 0xd2, 0x11, 0x12, 0x51, 0x84, 0xf8, 0xf1, 0x0a,
	0x16, 0x1d, 0x43, 0x8a, 0x04, 0x62, 0x09, 0x54, 0x44, 0x88, 0x4a, 0x88, 0x02, 0x5b, 0x6b, 0x6c,
	0xdf, 0x38, 0x23, 0x6c, 0x8f, 0x99, 0x9f, 0x88, 0x3c, 0x0c, 0x6f, 0xc1, 0x03, 0x32, 0x1e, 0x3b,
	0xa4, 0x31, 0x82, 0x2c, 0xcf, 0xf8, 0xde, 0xf3, 0x9d, 0x7b, 0x64, 0x78, 0x52, 0x49, 0xa1, 0x45,
	0xa8, 0x30, 0x31, 0x92, 0xeb, 0x75, 0x94, 0xe8, 0x82, 0x55, 0x1d, 0x49, 0xdd, 0x0c, 0x39, 0xd9,
	0x7d, 0x9d, 0xce, 0x33, 0xae, 0x97, 0x26, 0xa6, 0x89, 0x28, 0xc2, 0x4c, 0x88, 0x2c, 0xc7, 0x10,
	0x67, 0x78, 0xfe, 0x0d, 0xd7, 0xe7, 0x0a, 0xe5, 0x0a, 0x65, 0xd8, 0xf1, 0x76, 0x32, 0x36, 0x8b,
	0x50, 0xf3, 0x02, 0x95, 0x66, 0x45, 0xeb, 0x1c, 0x70, 0x18, 0x5e, 0x56, 0x22, 0x59, 0xce, 0x91,
	0xa5, 0x64, 0x0c, 0x47, 0x12, 0x59, 0x5e, 0x4c, 0xbc, 0x87, 0xde, 0xe3, 0x61, 0x2d, 0xb1, 0xfe,
	0x36, 0x39, 0xb4, 0xb2, 0x47, 0x7c, 0xe8, 0x4b, 0x21, 0xf4, 0xa4, 0x67, 0x95, 0x4f, 0x9e, 0x02,
	0x70, 0xa5, 0x0c, 0x46, 0xb5, 0xe3, 0xa4, 0x6f, 0xdf, 0x46, 0xb3, 0x7b, 0x74, 0x03, 0xa4, 0x1b,
	0x20, 0xfd, 0xbc, 0x01, 0x06, 0x3f, 0x3d, 0x38, 0xbd, 0xe6, 0x59, 0x89, 0xe9, 0x96, 0x48, 0x00,
	0x1c, 0x22, 0x5a, 0x5a, 0xe5, 0xb0, 0x3e, 0x79, 0x03, 0xa0, 0xec, 0x18, 0xd3, 0x46, 0xa2, 0xb2,
	0xec, 0x9e, 0x75, 0x0e, 0x69, 0xa7, 0x97, 0x8e, 0x91, 0xd3, 0xcd, 0xc6, 0x65, 0xa9, 0xe5, 0x7a,
	0xfa, 0xac, 0x61, 0xdd, 0x78, 0x22, 0x23, 0xe8, 0xd9, 0x82, 0x1c, 0x64, 0x50, 0xdf, 0xb6, 0x62,
	0xb9, 0x41, 0x77, 0x9b, 0xff, 0xea, 0xf0, 0xa5, 0x17, 0x50, 0x38, 0x79, 0x87, 0xfa, 0x03, 0xb2,
	0xc5, 0x27, 0xfc, 0x6e, 0x6c, 0xe8, 0x7a, 0x88, 0x97, 0x29, 0xfe, 0x68, 0x83, 0xed, 0xf4, 0xd1,
	0x0f, 0x5e, 0xc0, 0xe9, 0x9f, 0x79, 0x55, 0x89, 0x52, 0x21, 0x39, 0x83, 0x61, 0x6e, 0x75, 0x94,
	0x32, 0xcd, 0xda, 0x25, 0xfb, 0x54, 0x22, 0xcf, 0x96, 0xb1, 0x90, 0xcd, 0x31, 0x7e, 0xf0, 0x1c,
	0xce, 0xbe, 0x54, 0x76, 0x04, 0xff, 0xc3, 0xba, 0x0d, 0xc7, 0x85, 0xd1, 0x4c, 0x73, 0x51, 0x36,
	0x11, 0x83, 0xb7, 0x40, 0x6e, 0x6e, 0xb5, 0x44, 0x0a, 0x47, 0xb6, 0x6a, 0xb1, 0x70, 0x6b, 0xa3,
	0xd9, 0x83, 0x6e, 0x4f, 0x9d, 0x84, 0x01, 0xc2, 0xf8, 0xaa, 0xf5, 0x6d, 0x5a, 0xb9, 0x80, 0x81,
	0x71, 0xb6, 0xad, 0xc3, 0xa3, 0xae, 0xc3, 0x5f, 0x51, 0xe7, 0x07, 0xe4, 0x2e, 0x8c, 0x59, 0xba,
	0x62, 0x65, 0x82, 0xd1, 0xb6, 0x91, 0xe3, 0xf9, 0xc1, 0xeb, 0x01, 0xf4, 0xf5, 0xba, 0xc2, 0xd9,
	0x2f, 0x0f, 0xee, 0x7c, 0x45, 0xc9, 0x17, 0x9c, 0xc5, 0x39, 0x5e, 0xb1, 0xea, 0xda, 0xfe, 0x96,
	0x3c, 0x41, 0xf2, 0x1e, 0x6e, 0xb5, 0x91, 0xc8, 0xfd, 0x7f, 0x66, 0x75, 0x98, 0xe9, 0xbe, 0x5b,
	0xc8, 0x47, 0x80, 0x6d, 0x38, 0xb2, 0x3f, 0xf8, 0x5e, 0xc7, 0x78, 0xe0, 0x7e, 0xdb, 0x8b, 0xdf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xfe, 0xd4, 0xe1, 0x61, 0x9b, 0x03, 0x00, 0x00,
}
