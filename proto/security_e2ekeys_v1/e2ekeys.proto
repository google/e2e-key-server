// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package security.e2ekeys.v1;

import "github.com/google/e2e-key-server/proto/security_ctmap/security_ctmap.proto";
import "google/api/annotations.proto";

// The E2EKeyService API represents a directory of public keys.
// The API defines the following resource model:
//
// - The API has a collection of  [Entry][security.e2ekeys.Entry]
//   resources named `/entries/*`.
//
// - Entries have a collection of historical
//   [Entry][security.e2ekeys.Entry] resources named
//   `/entries/*/history`.
//
service E2EKeyService {
  // GetEntry returns a user's entry in the Merkle Tree. Entries contain
  // signed commitments to a profile, which is also returned.
  rpc GetEntry(GetEntryRequest) returns (GetEntryResponse) {
    option (google.api.http) = { get: "/v1/users/{user_id}" };
  }

  // ListEntryHistory returns a list of GetEntryRespons covering several epochs.
  rpc ListEntryHistory(ListEntryHistoryRequest) returns (ListEntryHistoryResponse) {
    option (google.api.http) = { get: "/v1/users/{user_id}/history" };
  }

  // blocking or polling?
  // UpdateEntry submits a SignedEntryUpdate.  Returns empty until this update
  // has been included in an epoch.  Clients must retry until this function
  // returns a proof.
  rpc UpdateEntry(UpdateEntryRequest) returns (UpdateEntryResponse) {
    option (google.api.http) = {
      put: "/v1/users/{user_id}"
      body: "entry_update"
    };
  }


/*
  // List the Signed Epoch Heads, from epoch to epoch.
  rpc ListSEH(ListSEHRequest) returns (ListSEHResponse);

  // List the EntryUpdates by update number.
  rpc ListUpdate(ListUpdateRequest) returns (ListUpdateResponse);

  // ListSteps combines SEH and EntryUpdates into single list.
  rpc ListSteps(ListStepsRequest) returns (ListStepsResponse);
*/
  rpc HkpLookup(HkpLookupRequest) returns (HttpResponse){
    option (google.api.http) = { get: "/v1/hkp/lookup" };
  }
}

//
// Data types.
//

// HkpLookupRequest contains query parameters for retrieving PGP keys.
message HkpLookupRequest {
  // Op specifies the operation to be performed on the keyserver.
  // - "get" returns the pgp key specified in the search parameter.
  // - "index" returns 501 (not implemented).
  // - "vindex" returns 501 (not implemented).
  string op = 1;
  // Search specifies the email address or key id being queried.
  string search = 2;
  // Options specifies what output format to use.
  // - "mr" machine readable will set the content type to "application/pgp-keys"
  // - other options will be ignored.
  string options = 3;
  // Exact specifies an exact match on search. Always on. If specified in the
  // URL, its value will be ignored.
  string exact = 4;
  // fingerprint is ignored.
  string fingerprint = 5;
}

// HttpBody represents an http body.
message HttpResponse {
  // Header content type.
  string content_type = 1;
  // The http body itself.
  bytes body = 2;
}

// GetEntryResponse 
message GetEntryResponse {
  //
  // Privacy layer hides user_id and profile data until requested.
  //

  // vrf is the output of VRF on user_id.
  bytes vrf = 1;
  // vrf_proof is the proof for VRF on user_id.
  bytes vrf_proof = 2;

  // TODO: Combine into Commitment datatype.
  // commitment_key connects the profile data to the commitment in leaf_proof.
  bytes commitment_key = 3;
  // profile contains the public key data for this account.
  bytes profile = 4;

  //
  // Verifiable map layer proves that the response is consistent.
  //

  // leaf_proof contains an Entry and an inclusion proof in the sparse merkle tree at end_epoch.
  security_ctmap.GetLeafResponse leaf_proof = 5;
  // seh contains the signed epoch head for the sparse merkle tree. 
  // seh is also stored in the append only log.
  security_ctmap.SignedEpochHead seh = 6;
  // seh_sct is the SCT showing that seh was submitted to CT logs.
  // TODO: Support storing seh in multiple logs.
  bytes seh_sct = 7;

  //
  // Append only log layer proves that all account histories are consistent.
  //

  // Inclusion proof for the signed epoch head at end_epoch in the log of signed epoch heads.
  //ct.GetEntryAndProofResponse audit_proof = 7;
  // TODO: Supply GetEntryAndProofRequest data
  // Latest signed tree head of the log of signed epoch heads.
  //ct.GetSTHResponse sth = 8;
  // Consistency proof between epoch_start and the current sth.
  //ct.GetConsistencyProofResponse consistency_proof = 9;
}

// Profile contains data hidden behind the crypto comitment.
message Profile {
  // Keys is a map of appIds to keys.
  map<string, bytes> keys = 1;
}


//
// Verifiable Map Leaf Data and Mutation Data.
//

// Entry contains a commitment to profile and a set of authorized update keys.
// Entry is placed in the verifiable map as leaf data.
message Entry {
  // commitment is a cryptographic commitment to arbitrary data.
  bytes commitment = 1;
  // authorized_keys is the set of keys allowed to sign updates for this entry.
  repeated PublicKey authorized_keys = 2;
  // update_count prevents replay attacks. Monotonically increasing.
  uint64 update_count = 3;
}

// PublicKey defines a key this domain uses to sign EpochHeads with.
message PublicKey {
  // KeyFormats from Keyczar.
  oneof key_type {
    bytes ed25519 = 1; // 32 bytes (<http://ed25519.cr.yp.to/>)
    bytes rsa_verifying_sha256_2048 = 2;
    bytes ecdsa_verifying_p256 = 3;
  }
}

// KeyValue is a map entry.
message KeyValue {
   bytes key = 1;
   bytes value = 2;
}

// SignedKV is a signed change to a map entry.
message SignedKV {
  // keyvalue is a serialized KeyValue.
  bytes key_value = 1;
  // signatures on keyvalue. Must be signed by keys from both previous and 
  // current epochs. The first proves ownership of new epoch key, and the
  // second proves the the correct owner is making this change.
  map<fixed64, bytes> signatures = 2;
  // TODO: Add hash of previous value to make mutations reliable.
}

//
// RPC request/response messages.
//

// Get request for a user object.
message GetEntryRequest {
  // Last trusted epoch by the client.
  //int64 epoch_start = 3; 
  // Absence of the epoch_end field indicates a request for the current value.
  int64 epoch_end = 1;
  // User identifier. Most commonly an email address.
  string user_id = 2;
}

// Get a list of historical values for a user.
message ListEntryHistoryRequest {
  // The user identifier.
  string user_id = 1;
  // from_epoch is the starting epcoh.
  int64 start_epoch = 2;
  // The maximum number of entries to return.
  int32 page_size = 3;
}

// A paginated history of values for a user.
message ListEntryHistoryResponse {
  // The list of values this user_id has contained over time.
  repeated GetEntryResponse values = 1;
  // The next time to query for pagination.
  int64 next_epoch = 2;
}

message EntryUpdate {
  // update authorizes the change to profile.
  SignedKV update = 2; // TODO: make this bytes
  // profile is the serialized protobuf Profile.
  bytes profile = 3;
  // commitment_key is 16 random bytes.
  bytes commitment_key = 4;
  // Last trusted epoch by the client.
  // int64 epoch_start = 6; 
}

// Update a user's profile.
message UpdateEntryRequest {
  // user_id specifies the id for the new account to be registered.
  string user_id = 1; 
  EntryUpdate entry_update = 2;
}

// UpdateEntryResponse contains a proof once the update has been included in
// the Merkel Tree.
message UpdateEntryResponse {
  GetEntryResponse proof = 1;
}
