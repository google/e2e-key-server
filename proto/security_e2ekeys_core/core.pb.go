// Code generated by protoc-gen-go.
// source: proto/security_e2ekeys_core/core.proto
// DO NOT EDIT!

/*
Package security_e2ekeys_core is a generated protocol buffer package.

It is generated from these files:
	proto/security_e2ekeys_core/core.proto

It has these top-level messages:
	DomainInfo
	VerifierInfo
*/
package security_e2ekeys_core

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import security_ctmap "github.com/google/e2e-key-server/proto/security_ctmap"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// DomainInfo is the information that need to be baked into an application
// in order to verify information for a domain.
type DomainInfo struct {
	PublicKeys []*security_ctmap.PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty"`
	// required_sigs is the number of valid signatures to require out of
	// public_keys before considering signed_tree heads legitimate.
	RequiredSigs uint32 `protobuf:"varint,2,opt,name=required_sigs" json:"required_sigs,omitempty"`
	// domain is the doman suffix to use when resolving a user_id to a domain.
	Domain string `protobuf:"bytes,3,opt,name=domain" json:"domain,omitempty"`
	// api_url is the url prefix to use when querying users on this domain.
	ApiUrl string `protobuf:"bytes,4,opt,name=api_url" json:"api_url,omitempty"`
}

func (m *DomainInfo) Reset()                    { *m = DomainInfo{} }
func (m *DomainInfo) String() string            { return proto.CompactTextString(m) }
func (*DomainInfo) ProtoMessage()               {}
func (*DomainInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DomainInfo) GetPublicKeys() []*security_ctmap.PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

type VerifierInfo struct {
	PublicKeys []*security_ctmap.PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty"`
	// required_sigs is the number of valid signatures to require out of
	// public_keys before considering signed_tree heads legitimate.
	RequiredSigs uint32 `protobuf:"varint,2,opt,name=required_sigs" json:"required_sigs,omitempty"`
	// api_url is the url prefix to use when querying users on this domain.
	ApiUrl string `protobuf:"bytes,4,opt,name=api_url" json:"api_url,omitempty"`
	// domain is the doman suffix that this verifier is responsible for.
	Domain string `protobuf:"bytes,3,opt,name=domain" json:"domain,omitempty"`
}

func (m *VerifierInfo) Reset()                    { *m = VerifierInfo{} }
func (m *VerifierInfo) String() string            { return proto.CompactTextString(m) }
func (*VerifierInfo) ProtoMessage()               {}
func (*VerifierInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *VerifierInfo) GetPublicKeys() []*security_ctmap.PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func init() {
	proto.RegisterType((*DomainInfo)(nil), "security.e2ekeys.core.DomainInfo")
	proto.RegisterType((*VerifierInfo)(nil), "security.e2ekeys.core.VerifierInfo")
}

var fileDescriptor0 = []byte{
	// 231 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x8f, 0x4d, 0x4b, 0x03, 0x31,
	0x10, 0x86, 0xa9, 0x95, 0x8a, 0x53, 0xab, 0x10, 0x28, 0xac, 0x9e, 0x4a, 0x0f, 0xd2, 0x4b, 0x13,
	0xa8, 0xbf, 0x40, 0xf0, 0x22, 0x5e, 0x3c, 0x79, 0x0d, 0xfb, 0x31, 0xbb, 0x0e, 0xee, 0x6e, 0xd6,
	0x49, 0xb2, 0xb0, 0xff, 0xde, 0x24, 0xea, 0xc1, 0x3d, 0x7b, 0x48, 0xe0, 0x4d, 0x9e, 0xbc, 0x4f,
	0x06, 0xee, 0x07, 0x36, 0xce, 0x28, 0x8b, 0xa5, 0x67, 0x72, 0x93, 0xc6, 0x13, 0x7e, 0xe0, 0x64,
	0x75, 0x69, 0x18, 0x55, 0xdc, 0x64, 0x02, 0xc4, 0xf6, 0x97, 0x90, 0x3f, 0x84, 0x8c, 0x97, 0x77,
	0x8f, 0x0d, 0xb9, 0x77, 0x5f, 0x84, 0xd0, 0xa9, 0xa6, 0x2a, 0xb0, 0x1d, 0xa9, 0x57, 0x81, 0x38,
	0x06, 0xe4, 0x68, 0x91, 0x47, 0x64, 0x35, 0x33, 0x94, 0xae, 0xcb, 0x07, 0x15, 0xd6, 0x77, 0xf3,
	0xde, 0x01, 0x3c, 0x99, 0x2e, 0xa7, 0xfe, 0xb9, 0xaf, 0x8d, 0x90, 0xb0, 0x1e, 0x7c, 0xd1, 0x52,
	0xa9, 0xa3, 0x24, 0x5b, 0xec, 0x96, 0x87, 0xf5, 0xe9, 0x56, 0xfe, 0x7d, 0x2d, 0x5f, 0x13, 0xf2,
	0x82, 0x93, 0xd8, 0xc2, 0x86, 0xf1, 0xd3, 0x13, 0x63, 0xa5, 0x2d, 0x35, 0x36, 0x3b, 0xdb, 0x2d,
	0x0e, 0x1b, 0x71, 0x0d, 0xab, 0x2a, 0x95, 0x66, 0xcb, 0x90, 0x2f, 0xc5, 0x0d, 0x5c, 0xe4, 0x03,
	0x69, 0xcf, 0x6d, 0x76, 0x1e, 0x0f, 0xf6, 0x23, 0x5c, 0xbd, 0x21, 0x53, 0x4d, 0xc8, 0xff, 0xe9,
	0x9d, 0x7b, 0xe6, 0x1f, 0x29, 0x56, 0x69, 0xe8, 0x87, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5d,
	0x92, 0x58, 0xf7, 0x78, 0x01, 0x00, 0x00,
}
