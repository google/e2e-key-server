// Code generated by protoc-gen-go.
// source: proto/security_e2ekeys_core/core.proto
// DO NOT EDIT!

/*
Package security_e2ekeys_core is a generated protocol buffer package.

It is generated from these files:
	proto/security_e2ekeys_core/core.proto

It has these top-level messages:
	EntryStorage
	EpochInfo
	DomainInfo
	VerifierInfo
*/
package security_e2ekeys_core

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import security_ctmap "github.com/gdbelvin/e2e-key-server/proto/security_ctmap"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// EntryStorage is what gets serialized to disk / log.
type EntryStorage struct {
	// commitment_timestamp is a sequential update number of the SignedEntryUpdate.
	CommitmentTimestamp int64 `protobuf:"varint,1,opt,name=commitment_timestamp" json:"commitment_timestamp,omitempty"`
	// entry_update contains a SignedEntryUpdate proto with the actual update
	// contents.
	SignedEntryUpdate *security_ctmap.SignedEntryUpdate `protobuf:"bytes,2,opt,name=signed_entry_update" json:"signed_entry_update,omitempty"`
	// profile is the serialized protobuf Profile.
	// profile is private and must not be released to verifiers.
	Profile []byte `protobuf:"bytes,3,opt,name=profile,proto3" json:"profile,omitempty"`
	// commitment_key is at least 16 random bytes.
	CommitmentKey []byte `protobuf:"bytes,4,opt,name=commitment_key,proto3" json:"commitment_key,omitempty"`
	// domain allows servers to keep track of multiple trees at once.
	Domain string `protobuf:"bytes,5,opt,name=domain" json:"domain,omitempty"`
}

func (m *EntryStorage) Reset()                    { *m = EntryStorage{} }
func (m *EntryStorage) String() string            { return proto.CompactTextString(m) }
func (*EntryStorage) ProtoMessage()               {}
func (*EntryStorage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EntryStorage) GetSignedEntryUpdate() *security_ctmap.SignedEntryUpdate {
	if m != nil {
		return m.SignedEntryUpdate
	}
	return nil
}

// EpochInfo is what gets serialized to disk / log.
type EpochInfo struct {
	// signed_epoch_head is the signed epoch head of the created epoch.
	SignedEpochHead *security_ctmap.SignedEpochHead `protobuf:"bytes,1,opt,name=signed_epoch_head" json:"signed_epoch_head,omitempty"`
	// last_commitment_timestamp is the timestamp of the last update included in
	// created epoch.
	LastCommitmentTimestamp int64 `protobuf:"varint,2,opt,name=last_commitment_timestamp" json:"last_commitment_timestamp,omitempty"`
}

func (m *EpochInfo) Reset()                    { *m = EpochInfo{} }
func (m *EpochInfo) String() string            { return proto.CompactTextString(m) }
func (*EpochInfo) ProtoMessage()               {}
func (*EpochInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EpochInfo) GetSignedEpochHead() *security_ctmap.SignedEpochHead {
	if m != nil {
		return m.SignedEpochHead
	}
	return nil
}

// DomainInfo is the information that need to be baked into an application
// in order to verify information for a domain.
type DomainInfo struct {
	PublicKeys []*security_ctmap.PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty"`
	// required_sigs is the number of valid signatures to require out of
	// public_keys before considering signed_tree heads legitimate.
	RequiredSigs uint32 `protobuf:"varint,2,opt,name=required_sigs" json:"required_sigs,omitempty"`
	// domain is the doman suffix to use when resolving a user_id to a domain.
	Domain string `protobuf:"bytes,3,opt,name=domain" json:"domain,omitempty"`
	// api_url is the url prefix to use when querying users on this domain.
	ApiUrl string `protobuf:"bytes,4,opt,name=api_url" json:"api_url,omitempty"`
}

func (m *DomainInfo) Reset()                    { *m = DomainInfo{} }
func (m *DomainInfo) String() string            { return proto.CompactTextString(m) }
func (*DomainInfo) ProtoMessage()               {}
func (*DomainInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DomainInfo) GetPublicKeys() []*security_ctmap.PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

type VerifierInfo struct {
	PublicKeys []*security_ctmap.PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty"`
	// required_sigs is the number of valid signatures to require out of
	// public_keys before considering signed_tree heads legitimate.
	RequiredSigs uint32 `protobuf:"varint,2,opt,name=required_sigs" json:"required_sigs,omitempty"`
	// api_url is the url prefix to use when querying users on this domain.
	ApiUrl string `protobuf:"bytes,4,opt,name=api_url" json:"api_url,omitempty"`
	// domain is the doman suffix that this verifier is responsible for.
	Domain string `protobuf:"bytes,3,opt,name=domain" json:"domain,omitempty"`
}

func (m *VerifierInfo) Reset()                    { *m = VerifierInfo{} }
func (m *VerifierInfo) String() string            { return proto.CompactTextString(m) }
func (*VerifierInfo) ProtoMessage()               {}
func (*VerifierInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *VerifierInfo) GetPublicKeys() []*security_ctmap.PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func init() {
	proto.RegisterType((*EntryStorage)(nil), "security.e2ekeys.core.EntryStorage")
	proto.RegisterType((*EpochInfo)(nil), "security.e2ekeys.core.EpochInfo")
	proto.RegisterType((*DomainInfo)(nil), "security.e2ekeys.core.DomainInfo")
	proto.RegisterType((*VerifierInfo)(nil), "security.e2ekeys.core.VerifierInfo")
}

var fileDescriptor0 = []byte{
	// 364 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x92, 0x4f, 0x4b, 0xfb, 0x30,
	0x18, 0xc7, 0xd9, 0xaf, 0x3f, 0x27, 0xcd, 0xfe, 0x88, 0xd1, 0x49, 0x27, 0x82, 0xae, 0x07, 0xf1,
	0xb2, 0x16, 0xe6, 0xcd, 0x83, 0x20, 0x38, 0x50, 0xbc, 0x08, 0x43, 0xaf, 0x21, 0x6d, 0x9f, 0x75,
	0xd1, 0xfe, 0x33, 0x49, 0x07, 0x7d, 0x41, 0xbe, 0x4f, 0x9f, 0x44, 0x07, 0xb3, 0xe8, 0xcd, 0x43,
	0x0b, 0x49, 0x3e, 0x79, 0x3e, 0xdf, 0x6f, 0x29, 0x39, 0xaf, 0x64, 0xa9, 0xcb, 0x50, 0x41, 0x5c,
	0x4b, 0xa1, 0x1b, 0x06, 0x33, 0x78, 0x85, 0x46, 0xb1, 0xb8, 0x94, 0x10, 0x9a, 0x57, 0x60, 0x01,
	0x3a, 0xda, 0x10, 0xc1, 0x17, 0x11, 0x98, 0xc3, 0xe3, 0x9b, 0x54, 0xe8, 0x55, 0x1d, 0xe1, 0x22,
	0x0f, 0xd3, 0x24, 0x82, 0x6c, 0x2d, 0x8a, 0x10, 0x89, 0x29, 0x22, 0x53, 0x05, 0x72, 0x0d, 0x32,
	0x6c, 0x19, 0x62, 0x9d, 0xf3, 0x2a, 0xc4, 0xe7, 0x73, 0xb2, 0xff, 0xde, 0x21, 0xfd, 0x79, 0xa1,
	0x65, 0xb3, 0xd0, 0xa5, 0xe4, 0x29, 0xd0, 0x13, 0x72, 0x88, 0xe3, 0x72, 0xa1, 0x73, 0x28, 0x34,
	0xd3, 0x22, 0x07, 0xa5, 0x79, 0x5e, 0x79, 0x9d, 0xb3, 0xce, 0x85, 0x43, 0xaf, 0xc9, 0x81, 0x12,
	0x69, 0x01, 0x09, 0x03, 0x73, 0x89, 0xd5, 0x55, 0xc2, 0x35, 0x78, 0xff, 0xf0, 0xb0, 0x37, 0x9b,
	0x04, 0xdf, 0x35, 0xc1, 0xc2, 0xa2, 0x76, 0xfc, 0x93, 0x05, 0xe9, 0x1e, 0xd9, 0x45, 0xef, 0x52,
	0x64, 0xe0, 0x39, 0x78, 0xa7, 0x4f, 0x8f, 0xc8, 0x70, 0x4b, 0x87, 0xb9, 0xbd, 0xff, 0x76, 0x7f,
	0x48, 0xba, 0x49, 0x99, 0x73, 0x51, 0x78, 0x3b, 0xb8, 0x76, 0xfd, 0x17, 0xe2, 0xce, 0xab, 0x32,
	0x5e, 0xdd, 0x17, 0xcb, 0x92, 0x5e, 0x91, 0xfd, 0x4d, 0x0a, 0xb3, 0xc7, 0x56, 0xc0, 0x13, 0x1b,
	0xb0, 0x37, 0x3b, 0xfd, 0x25, 0x83, 0xe1, 0xee, 0x10, 0xa3, 0x13, 0x32, 0xce, 0xb8, 0xd2, 0xec,
	0xc7, 0x92, 0xa6, 0x87, 0xe3, 0x6b, 0x42, 0x6e, 0xad, 0xdb, 0xca, 0x02, 0xd2, 0xab, 0xea, 0x28,
	0x13, 0xb1, 0x49, 0xa7, 0x50, 0xe3, 0xa0, 0x66, 0xdc, 0xd6, 0x3c, 0x5a, 0xe4, 0x01, 0x1a, 0x3a,
	0x22, 0x03, 0x09, 0x6f, 0xb5, 0x90, 0x18, 0x0f, 0x53, 0x2a, 0x3b, 0x74, 0xb0, 0x55, 0xc8, 0x14,
	0x77, 0xcd, 0x97, 0xe0, 0x95, 0x60, 0xb5, 0xcc, 0x6c, 0x63, 0xd7, 0x5f, 0x93, 0xfe, 0x33, 0x48,
	0xb1, 0x14, 0x20, 0xff, 0xd2, 0xdb, 0xf6, 0xb4, 0x83, 0x44, 0x5d, 0xfb, 0x23, 0x5c, 0x7e, 0x04,
	0x00, 0x00, 0xff, 0xff, 0x1f, 0xe6, 0xa1, 0x4a, 0x8c, 0x02, 0x00, 0x00,
}
