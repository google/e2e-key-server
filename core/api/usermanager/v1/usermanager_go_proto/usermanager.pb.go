// Code generated by protoc-gen-go. DO NOT EDIT.
// source: usermanager/v1/usermanager.proto

/*
Package usermanager_go_proto is a generated protocol buffer package.

It is generated from these files:
	usermanager/v1/usermanager.proto

It has these top-level messages:
	GetKeySetRequest
	CreateUserRequest
	UpdateUserRequest
	BatchCreateUserRequest
	BatchCreateUserResponse
*/
package usermanager_go_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "google.golang.org/genproto/protobuf/field_mask"
import google_keytransparency_type "github.com/google/keytransparency/core/api/type/type_go_proto"
import google_keytransparency_type1 "github.com/google/keytransparency/core/api/type/type_go_proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// GetKeySetsRequest requests the keyset of a domain_id/app_id
type GetKeySetRequest struct {
	// domain_id identifies the domain.
	DomainId string `protobuf:"bytes,1,opt,name=domain_id,json=domainId" json:"domain_id,omitempty"`
	// app_id identifies the application.
	AppId string `protobuf:"bytes,2,opt,name=app_id,json=appId" json:"app_id,omitempty"`
}

func (m *GetKeySetRequest) Reset()                    { *m = GetKeySetRequest{} }
func (m *GetKeySetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetKeySetRequest) ProtoMessage()               {}
func (*GetKeySetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GetKeySetRequest) GetDomainId() string {
	if m != nil {
		return m.DomainId
	}
	return ""
}

func (m *GetKeySetRequest) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

// CreateUserRequest specifies the information with which a new user should be initialized.
// New users will be signed with the current active key.
// It is the responsibility of authorized callers to verify that domain_id/app_id/user_id is correct.
type CreateUserRequest struct {
	// user is the user to create.
	User *google_keytransparency_type.User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// add_signing_keys specifies whether to add this service's signing keys to the set of authorized_keys.
	// This must be set to true if any further operations from this API are meant to succeed.
	// If set to false, there must be at least one key in authorized_keys.
	AddSigningKeys bool `protobuf:"varint,7,opt,name=add_signing_keys,json=addSigningKeys" json:"add_signing_keys,omitempty"`
}

func (m *CreateUserRequest) Reset()                    { *m = CreateUserRequest{} }
func (m *CreateUserRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateUserRequest) ProtoMessage()               {}
func (*CreateUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CreateUserRequest) GetUser() *google_keytransparency_type.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *CreateUserRequest) GetAddSigningKeys() bool {
	if m != nil {
		return m.AddSigningKeys
	}
	return false
}

// UpdateUserRequest sets the data field for the user.
// The user must have the service's current signing key in its list of
// authorized_keys in order to succeed.
type UpdateUserRequest struct {
	// user contains data which will be applied to the user.
	User *google_keytransparency_type.User `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	// update_mask specifies which fields of user to update.
	// For example: "data" or "authorized_keys"
	UpdateMask *google_protobuf1.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateUserRequest) Reset()                    { *m = UpdateUserRequest{} }
func (m *UpdateUserRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserRequest) ProtoMessage()               {}
func (*UpdateUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UpdateUserRequest) GetUser() *google_keytransparency_type.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UpdateUserRequest) GetUpdateMask() *google_protobuf1.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// BatchCreateUserRequest creates multiple users all at once.
type BatchCreateUserRequest struct {
	// domain_id identifies the domain.
	DomainId string `protobuf:"bytes,1,opt,name=domain_id,json=domainId" json:"domain_id,omitempty"`
	// app_id identifies the application.
	AppId string `protobuf:"bytes,2,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	// users is the set of users to create.
	Users []*google_keytransparency_type.User `protobuf:"bytes,3,rep,name=users" json:"users,omitempty"`
	// add_signing_keys specifies whether to add this service's signing_keys to the set of authorized_keys.
	// This must be set to true if any further operations from this API are meant to succeed.
	// If set to false, there must be at least one key in authorized_keys.
	AddSigningKeys bool `protobuf:"varint,4,opt,name=add_signing_keys,json=addSigningKeys" json:"add_signing_keys,omitempty"`
}

func (m *BatchCreateUserRequest) Reset()                    { *m = BatchCreateUserRequest{} }
func (m *BatchCreateUserRequest) String() string            { return proto.CompactTextString(m) }
func (*BatchCreateUserRequest) ProtoMessage()               {}
func (*BatchCreateUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *BatchCreateUserRequest) GetDomainId() string {
	if m != nil {
		return m.DomainId
	}
	return ""
}

func (m *BatchCreateUserRequest) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *BatchCreateUserRequest) GetUsers() []*google_keytransparency_type.User {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *BatchCreateUserRequest) GetAddSigningKeys() bool {
	if m != nil {
		return m.AddSigningKeys
	}
	return false
}

// BatchCreateUserResponse creates multiple users at once.
type BatchCreateUserResponse struct {
	// users returns the list of created users.
	Users []*google_keytransparency_type.User `protobuf:"bytes,2,rep,name=users" json:"users,omitempty"`
}

func (m *BatchCreateUserResponse) Reset()                    { *m = BatchCreateUserResponse{} }
func (m *BatchCreateUserResponse) String() string            { return proto.CompactTextString(m) }
func (*BatchCreateUserResponse) ProtoMessage()               {}
func (*BatchCreateUserResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *BatchCreateUserResponse) GetUsers() []*google_keytransparency_type.User {
	if m != nil {
		return m.Users
	}
	return nil
}

func init() {
	proto.RegisterType((*GetKeySetRequest)(nil), "google.keytransparency.usermanager.v1.GetKeySetRequest")
	proto.RegisterType((*CreateUserRequest)(nil), "google.keytransparency.usermanager.v1.CreateUserRequest")
	proto.RegisterType((*UpdateUserRequest)(nil), "google.keytransparency.usermanager.v1.UpdateUserRequest")
	proto.RegisterType((*BatchCreateUserRequest)(nil), "google.keytransparency.usermanager.v1.BatchCreateUserRequest")
	proto.RegisterType((*BatchCreateUserResponse)(nil), "google.keytransparency.usermanager.v1.BatchCreateUserResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for UserManager service

type UserManagerClient interface {
	// GetKeySet returns a list of public keys (a keyset) that corresponds to the signing keys
	// this service has for a given domain and app.
	GetKeySet(ctx context.Context, in *GetKeySetRequest, opts ...grpc.CallOption) (*google_keytransparency_type1.KeySet, error)
	// CreateUser creates a new user and initializes it.
	// If the user already exists, this operation will fail.
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*google_keytransparency_type.User, error)
	// UpdateUserData sets the public key for an user.
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*google_keytransparency_type.User, error)
	// BatchCreateUser creates a set of new users.
	BatchCreateUser(ctx context.Context, in *BatchCreateUserRequest, opts ...grpc.CallOption) (*google_keytransparency_type.User, error)
}

type userManagerClient struct {
	cc *grpc.ClientConn
}

func NewUserManagerClient(cc *grpc.ClientConn) UserManagerClient {
	return &userManagerClient{cc}
}

func (c *userManagerClient) GetKeySet(ctx context.Context, in *GetKeySetRequest, opts ...grpc.CallOption) (*google_keytransparency_type1.KeySet, error) {
	out := new(google_keytransparency_type1.KeySet)
	err := grpc.Invoke(ctx, "/google.keytransparency.usermanager.v1.UserManager/GetKeySet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManagerClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*google_keytransparency_type.User, error) {
	out := new(google_keytransparency_type.User)
	err := grpc.Invoke(ctx, "/google.keytransparency.usermanager.v1.UserManager/CreateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManagerClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*google_keytransparency_type.User, error) {
	out := new(google_keytransparency_type.User)
	err := grpc.Invoke(ctx, "/google.keytransparency.usermanager.v1.UserManager/UpdateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManagerClient) BatchCreateUser(ctx context.Context, in *BatchCreateUserRequest, opts ...grpc.CallOption) (*google_keytransparency_type.User, error) {
	out := new(google_keytransparency_type.User)
	err := grpc.Invoke(ctx, "/google.keytransparency.usermanager.v1.UserManager/BatchCreateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserManager service

type UserManagerServer interface {
	// GetKeySet returns a list of public keys (a keyset) that corresponds to the signing keys
	// this service has for a given domain and app.
	GetKeySet(context.Context, *GetKeySetRequest) (*google_keytransparency_type1.KeySet, error)
	// CreateUser creates a new user and initializes it.
	// If the user already exists, this operation will fail.
	CreateUser(context.Context, *CreateUserRequest) (*google_keytransparency_type.User, error)
	// UpdateUserData sets the public key for an user.
	UpdateUser(context.Context, *UpdateUserRequest) (*google_keytransparency_type.User, error)
	// BatchCreateUser creates a set of new users.
	BatchCreateUser(context.Context, *BatchCreateUserRequest) (*google_keytransparency_type.User, error)
}

func RegisterUserManagerServer(s *grpc.Server, srv UserManagerServer) {
	s.RegisterService(&_UserManager_serviceDesc, srv)
}

func _UserManager_GetKeySet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeySetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManagerServer).GetKeySet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.usermanager.v1.UserManager/GetKeySet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManagerServer).GetKeySet(ctx, req.(*GetKeySetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManager_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManagerServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.usermanager.v1.UserManager/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManagerServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManager_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManagerServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.usermanager.v1.UserManager/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManagerServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManager_BatchCreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManagerServer).BatchCreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.usermanager.v1.UserManager/BatchCreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManagerServer).BatchCreateUser(ctx, req.(*BatchCreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.keytransparency.usermanager.v1.UserManager",
	HandlerType: (*UserManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetKeySet",
			Handler:    _UserManager_GetKeySet_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _UserManager_CreateUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserManager_UpdateUser_Handler,
		},
		{
			MethodName: "BatchCreateUser",
			Handler:    _UserManager_BatchCreateUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usermanager/v1/usermanager.proto",
}

func init() { proto.RegisterFile("usermanager/v1/usermanager.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 568 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xdd, 0x6a, 0x13, 0x41,
	0x14, 0x66, 0x9b, 0x36, 0x36, 0x13, 0xb0, 0xed, 0xe0, 0x4f, 0x88, 0x5e, 0xc4, 0x15, 0x21, 0x78,
	0xb1, 0x43, 0x23, 0xd2, 0x12, 0x29, 0x48, 0x84, 0x6a, 0x29, 0x95, 0x92, 0x52, 0x10, 0x2f, 0x5c,
	0xa6, 0x99, 0xd3, 0xed, 0x92, 0x66, 0x66, 0xdc, 0x99, 0x14, 0x96, 0xd2, 0x1b, 0x6f, 0x7c, 0x80,
	0x3e, 0x86, 0x17, 0x3e, 0x81, 0x0f, 0xe0, 0xb5, 0xaf, 0xe0, 0x83, 0xc8, 0xcc, 0x64, 0x9b, 0x90,
	0x4d, 0x74, 0x23, 0x7a, 0x33, 0xc9, 0x9c, 0xf9, 0x66, 0xce, 0xf7, 0x7d, 0x73, 0xce, 0x2c, 0x6a,
	0x0c, 0x15, 0x24, 0x03, 0xca, 0x69, 0x04, 0x09, 0xb9, 0xd8, 0x24, 0x13, 0xd3, 0x40, 0x26, 0x42,
	0x0b, 0xfc, 0x24, 0x12, 0x22, 0x3a, 0x87, 0xa0, 0x0f, 0xa9, 0x4e, 0x28, 0x57, 0x92, 0x26, 0xc0,
	0x7b, 0x69, 0x30, 0x89, 0xbc, 0xd8, 0xac, 0x3f, 0x74, 0x30, 0x42, 0x65, 0x4c, 0x28, 0xe7, 0x42,
	0x53, 0x1d, 0x0b, 0xae, 0xdc, 0x21, 0xf5, 0xc6, 0x68, 0xd5, 0xce, 0x4e, 0x86, 0xa7, 0xe4, 0x34,
	0x86, 0x73, 0x16, 0x0e, 0xa8, 0xea, 0x8f, 0x10, 0x6b, 0x3a, 0x95, 0x40, 0xcc, 0x30, 0x0a, 0xdc,
	0xb1, 0x81, 0x3e, 0xa4, 0x03, 0xaa, 0x74, 0xc6, 0xc6, 0xdf, 0x45, 0xeb, 0xaf, 0x41, 0xef, 0x43,
	0x7a, 0x04, 0xba, 0x0b, 0x1f, 0x87, 0xa0, 0x34, 0x7e, 0x80, 0x2a, 0x4c, 0x0c, 0x68, 0xcc, 0xc3,
	0x98, 0xd5, 0xbc, 0x86, 0xd7, 0xac, 0x74, 0x57, 0x5d, 0x60, 0x8f, 0xe1, 0xbb, 0xa8, 0x4c, 0xa5,
	0x34, 0x2b, 0x4b, 0x76, 0x65, 0x85, 0x4a, 0xb9, 0xc7, 0x7c, 0x8d, 0x36, 0x5e, 0x25, 0x40, 0x35,
	0x1c, 0x2b, 0x48, 0xb2, 0x83, 0x9e, 0xa3, 0x65, 0xa3, 0xca, 0x22, 0xab, 0xad, 0x47, 0xc1, 0x1c,
	0xe5, 0x96, 0xa4, 0xdd, 0x67, 0xe1, 0xb8, 0x89, 0xd6, 0x29, 0x63, 0xa1, 0x8a, 0x23, 0x1e, 0xf3,
	0x28, 0xec, 0x43, 0xaa, 0x6a, 0xb7, 0x1a, 0x5e, 0x73, 0xb5, 0x7b, 0x9b, 0x32, 0x76, 0xe4, 0xc2,
	0xfb, 0x90, 0x2a, 0xff, 0xb3, 0x87, 0x36, 0x8e, 0x25, 0xfb, 0x37, 0x69, 0x5f, 0xa0, 0xea, 0xd0,
	0x9e, 0x65, 0x6d, 0xac, 0x95, 0xec, 0xee, 0x7a, 0xb6, 0x3b, 0x73, 0x3a, 0xd8, 0x35, 0x4e, 0x1f,
	0x50, 0xd5, 0xef, 0x22, 0x07, 0x37, 0xff, 0xfd, 0xaf, 0x1e, 0xba, 0xd7, 0xa1, 0xba, 0x77, 0x96,
	0x77, 0xe1, 0x2f, 0xec, 0xc4, 0x5b, 0x68, 0xc5, 0x70, 0x52, 0xb5, 0x52, 0xa3, 0x54, 0x4c, 0x83,
	0xc3, 0xcf, 0xf4, 0x6e, 0x79, 0xa6, 0x77, 0x5d, 0x74, 0x3f, 0x47, 0x58, 0x49, 0xc1, 0x15, 0x8c,
	0xb3, 0x2f, 0x2d, 0x96, 0xbd, 0x75, 0x5d, 0x46, 0x55, 0x33, 0x3f, 0x70, 0x75, 0x8c, 0xbf, 0x78,
	0xa8, 0x72, 0x53, 0x5e, 0x78, 0x2b, 0x28, 0x54, 0xfa, 0xc1, 0x74, 0x41, 0xd6, 0x1f, 0xff, 0x96,
	0x80, 0xc3, 0xfa, 0x2f, 0x3f, 0xfd, 0xf8, 0x79, 0xbd, 0xd4, 0xc6, 0xdb, 0x64, 0xaa, 0x05, 0x9d,
	0xd7, 0x8a, 0x5c, 0xde, 0xdc, 0xc2, 0x15, 0xa1, 0x52, 0x2a, 0x72, 0xe9, 0x9c, 0xbf, 0x32, 0x4d,
	0xa1, 0x40, 0xe3, 0xef, 0x1e, 0x42, 0x63, 0x37, 0xf0, 0x76, 0x41, 0xba, 0xb9, 0x1b, 0xaf, 0xff,
	0xd9, 0x30, 0xff, 0x83, 0x65, 0xfb, 0xce, 0x3f, 0x9c, 0xcb, 0xd6, 0xc4, 0x83, 0x1c, 0x65, 0x1b,
	0xcd, 0x78, 0x5b, 0xd3, 0x47, 0x31, 0x33, 0x98, 0x60, 0xdb, 0x15, 0xb3, 0xd1, 0x32, 0xee, 0x8c,
	0xc2, 0x5a, 0x72, 0xcd, 0xb4, 0x80, 0x96, 0xd6, 0xff, 0xd2, 0xf2, 0xcd, 0x43, 0x6b, 0x53, 0xa5,
	0x8a, 0x77, 0x0a, 0x0a, 0x9a, 0xdd, 0x93, 0x45, 0x54, 0xbd, 0xb1, 0xaa, 0x3a, 0xfe, 0xce, 0xc2,
	0xf5, 0xd4, 0x9e, 0x48, 0xda, 0xf6, 0x9e, 0x76, 0x0e, 0xdf, 0xbf, 0x8d, 0x62, 0x7d, 0x36, 0x3c,
	0x09, 0x7a, 0x62, 0x40, 0x46, 0x2f, 0xf7, 0x54, 0x62, 0xd2, 0x13, 0x89, 0x7b, 0xec, 0xe7, 0x7f,
	0x40, 0xc2, 0x48, 0x84, 0xee, 0x19, 0x2a, 0xdb, 0x9f, 0x67, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff,
	0xaf, 0xbb, 0xee, 0x07, 0x6e, 0x06, 0x00, 0x00,
}
