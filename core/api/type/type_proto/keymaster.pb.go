// Code generated by protoc-gen-go. DO NOT EDIT.
// source: type/type_proto/keymaster.proto

package type_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// KeyStatus defines a key status.
type SigningKey_KeyStatus int32

const (
	SigningKey_UNKNOWN    SigningKey_KeyStatus = 0
	SigningKey_ACTIVE     SigningKey_KeyStatus = 1
	SigningKey_INACTIVE   SigningKey_KeyStatus = 2
	SigningKey_DEPRECATED SigningKey_KeyStatus = 3
)

var SigningKey_KeyStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "ACTIVE",
	2: "INACTIVE",
	3: "DEPRECATED",
}
var SigningKey_KeyStatus_value = map[string]int32{
	"UNKNOWN":    0,
	"ACTIVE":     1,
	"INACTIVE":   2,
	"DEPRECATED": 3,
}

func (x SigningKey_KeyStatus) String() string {
	return proto.EnumName(SigningKey_KeyStatus_name, int32(x))
}
func (SigningKey_KeyStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 0} }

// KeyStatus defines a key status.
type VerifyingKey_KeyStatus int32

const (
	VerifyingKey_UNKNOWN    VerifyingKey_KeyStatus = 0
	VerifyingKey_ACTIVE     VerifyingKey_KeyStatus = 1
	VerifyingKey_DEPRECATED VerifyingKey_KeyStatus = 2
)

var VerifyingKey_KeyStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "ACTIVE",
	2: "DEPRECATED",
}
var VerifyingKey_KeyStatus_value = map[string]int32{
	"UNKNOWN":    0,
	"ACTIVE":     1,
	"DEPRECATED": 2,
}

func (x VerifyingKey_KeyStatus) String() string {
	return proto.EnumName(VerifyingKey_KeyStatus_name, int32(x))
}
func (VerifyingKey_KeyStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{2, 0} }

type Metadata struct {
	// key_id represents a key identifier.
	KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId" json:"key_id,omitempty"`
	// added_at determines the time this key has been added to the key set.
	AddedAt *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=added_at,json=addedAt" json:"added_at,omitempty"`
	// description contains an arbitrary text describing the key.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *Metadata) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *Metadata) GetAddedAt() *google_protobuf1.Timestamp {
	if m != nil {
		return m.AddedAt
	}
	return nil
}

func (m *Metadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// SigningKey represents a private key.
type SigningKey struct {
	// metadata contains information about this key..
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// key_material contains the key material in PEM format.
	KeyMaterial []byte `protobuf:"bytes,2,opt,name=key_material,json=keyMaterial,proto3" json:"key_material,omitempty"`
	// status determines the status of this key, e.g., active, deprecated, etc.
	Status SigningKey_KeyStatus `protobuf:"varint,3,opt,name=status,enum=google.keytransparency.type.SigningKey_KeyStatus" json:"status,omitempty"`
}

func (m *SigningKey) Reset()                    { *m = SigningKey{} }
func (m *SigningKey) String() string            { return proto.CompactTextString(m) }
func (*SigningKey) ProtoMessage()               {}
func (*SigningKey) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *SigningKey) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *SigningKey) GetKeyMaterial() []byte {
	if m != nil {
		return m.KeyMaterial
	}
	return nil
}

func (m *SigningKey) GetStatus() SigningKey_KeyStatus {
	if m != nil {
		return m.Status
	}
	return SigningKey_UNKNOWN
}

// VerifyingKey represents a public key.
type VerifyingKey struct {
	// metadata contains information about this key..
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// key_material contains the key material in PEM format.
	KeyMaterial []byte `protobuf:"bytes,2,opt,name=key_material,json=keyMaterial,proto3" json:"key_material,omitempty"`
	// status determines the status of this key, e.g., active, deprecated, etc.
	Status VerifyingKey_KeyStatus `protobuf:"varint,3,opt,name=status,enum=google.keytransparency.type.VerifyingKey_KeyStatus" json:"status,omitempty"`
}

func (m *VerifyingKey) Reset()                    { *m = VerifyingKey{} }
func (m *VerifyingKey) String() string            { return proto.CompactTextString(m) }
func (*VerifyingKey) ProtoMessage()               {}
func (*VerifyingKey) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *VerifyingKey) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *VerifyingKey) GetKeyMaterial() []byte {
	if m != nil {
		return m.KeyMaterial
	}
	return nil
}

func (m *VerifyingKey) GetStatus() VerifyingKey_KeyStatus {
	if m != nil {
		return m.Status
	}
	return VerifyingKey_UNKNOWN
}

// KeySet contains a set of public and private keys.
type KeySet struct {
	// signing_keys holds a map of private keys keyed by the ID of their
	// corresponding public keys.
	SigningKeys map[string]*SigningKey `protobuf:"bytes,1,rep,name=signing_keys,json=signingKeys" json:"signing_keys,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// verifying_keys holds a map of public keys keyed by their IDs.
	VerifyingKeys map[string]*VerifyingKey `protobuf:"bytes,2,rep,name=verifying_keys,json=verifyingKeys" json:"verifying_keys,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *KeySet) Reset()                    { *m = KeySet{} }
func (m *KeySet) String() string            { return proto.CompactTextString(m) }
func (*KeySet) ProtoMessage()               {}
func (*KeySet) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *KeySet) GetSigningKeys() map[string]*SigningKey {
	if m != nil {
		return m.SigningKeys
	}
	return nil
}

func (m *KeySet) GetVerifyingKeys() map[string]*VerifyingKey {
	if m != nil {
		return m.VerifyingKeys
	}
	return nil
}

func init() {
	proto.RegisterType((*Metadata)(nil), "google.keytransparency.type.Metadata")
	proto.RegisterType((*SigningKey)(nil), "google.keytransparency.type.SigningKey")
	proto.RegisterType((*VerifyingKey)(nil), "google.keytransparency.type.VerifyingKey")
	proto.RegisterType((*KeySet)(nil), "google.keytransparency.type.KeySet")
	proto.RegisterEnum("google.keytransparency.type.SigningKey_KeyStatus", SigningKey_KeyStatus_name, SigningKey_KeyStatus_value)
	proto.RegisterEnum("google.keytransparency.type.VerifyingKey_KeyStatus", VerifyingKey_KeyStatus_name, VerifyingKey_KeyStatus_value)
}

func init() { proto.RegisterFile("type/type_proto/keymaster.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 507 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xdd, 0x6b, 0xd3, 0x50,
	0x14, 0x37, 0x29, 0xeb, 0xba, 0x93, 0x38, 0xc2, 0x05, 0xa1, 0xd4, 0x87, 0xd5, 0x80, 0x58, 0x5f,
	0x12, 0xec, 0xa6, 0xc8, 0x50, 0xa4, 0xdb, 0xf2, 0x50, 0xca, 0xaa, 0x64, 0x75, 0x03, 0x41, 0xca,
	0x6d, 0x73, 0x16, 0x2f, 0x69, 0x3e, 0xc8, 0xbd, 0x2d, 0x5c, 0xdf, 0xfc, 0x27, 0xfc, 0x57, 0x7d,
	0x95, 0xdc, 0xa4, 0x5b, 0x56, 0x47, 0xe9, 0x93, 0x2f, 0x49, 0xee, 0xc9, 0xfd, 0x7d, 0x9c, 0xdf,
	0xfd, 0x80, 0x23, 0x21, 0x33, 0x74, 0x8b, 0xc7, 0x34, 0xcb, 0x53, 0x91, 0xba, 0x11, 0xca, 0x98,
	0x72, 0x81, 0xb9, 0xa3, 0xc6, 0xe4, 0x79, 0x98, 0xa6, 0xe1, 0x02, 0x9d, 0x08, 0xa5, 0xc8, 0x69,
	0xc2, 0x33, 0x9a, 0x63, 0x32, 0x97, 0x4e, 0x01, 0xe9, 0x1c, 0x95, 0x3f, 0x5d, 0x35, 0x75, 0xb6,
	0xbc, 0x75, 0x05, 0x8b, 0x91, 0x0b, 0x1a, 0x67, 0x25, 0xda, 0xfe, 0x09, 0xad, 0x4b, 0x14, 0x34,
	0xa0, 0x82, 0x92, 0x67, 0xd0, 0x8c, 0x50, 0x4e, 0x59, 0xd0, 0xd6, 0xba, 0x5a, 0xef, 0xc0, 0xdf,
	0x8b, 0x50, 0x0e, 0x03, 0xf2, 0x16, 0x5a, 0x34, 0x08, 0x30, 0x98, 0x52, 0xd1, 0xd6, 0xbb, 0x5a,
	0xcf, 0xe8, 0x77, 0x9c, 0x4a, 0x73, 0x4d, 0xeb, 0x4c, 0xd6, 0xb4, 0xfe, 0xbe, 0x9a, 0x3b, 0x10,
	0xa4, 0x0b, 0x46, 0x80, 0x7c, 0x9e, 0xb3, 0x4c, 0xb0, 0x34, 0x69, 0x37, 0x14, 0x65, 0xbd, 0x64,
	0xff, 0xd2, 0x01, 0xae, 0x58, 0x98, 0xb0, 0x24, 0x1c, 0xa1, 0x24, 0x03, 0x68, 0xc5, 0x95, 0x15,
	0x65, 0xc0, 0xe8, 0xbf, 0x74, 0xb6, 0xf4, 0xe6, 0xac, 0x7d, 0xfb, 0x77, 0x30, 0xf2, 0x02, 0xcc,
	0xa2, 0x83, 0x98, 0x0a, 0xcc, 0x19, 0x5d, 0x28, 0xbb, 0xa6, 0x6f, 0x44, 0x28, 0x2f, 0xab, 0x12,
	0x19, 0x42, 0x93, 0x0b, 0x2a, 0x96, 0x5c, 0x39, 0x3a, 0xec, 0xbf, 0xd9, 0xaa, 0x71, 0x6f, 0xcf,
	0x19, 0xa1, 0xbc, 0x52, 0x40, 0xbf, 0x22, 0xb0, 0xcf, 0xe0, 0xe0, 0xae, 0x48, 0x0c, 0xd8, 0xff,
	0x3a, 0x1e, 0x8d, 0x3f, 0xdf, 0x8c, 0xad, 0x27, 0x04, 0xa0, 0x39, 0x38, 0x9f, 0x0c, 0xaf, 0x3d,
	0x4b, 0x23, 0x26, 0xb4, 0x86, 0xe3, 0x6a, 0xa4, 0x93, 0x43, 0x80, 0x0b, 0xef, 0x8b, 0xef, 0x9d,
	0x0f, 0x26, 0xde, 0x85, 0xd5, 0xb0, 0xff, 0x68, 0x60, 0x5e, 0x63, 0xce, 0x6e, 0xe5, 0x7f, 0x4d,
	0x61, 0xb4, 0x91, 0xc2, 0xf1, 0x56, 0x8d, 0xba, 0xc1, 0x47, 0x72, 0x38, 0xd9, 0x29, 0x87, 0x87,
	0x9d, 0xeb, 0xf6, 0xef, 0x06, 0x34, 0x0b, 0x18, 0x0a, 0x72, 0x03, 0x26, 0x2f, 0x83, 0x9e, 0x46,
	0x28, 0x79, 0x5b, 0xeb, 0x36, 0x7a, 0x46, 0xff, 0x64, 0xab, 0xa7, 0x12, 0x5a, 0x5b, 0x20, 0xee,
	0x25, 0x22, 0x97, 0xbe, 0xc1, 0xef, 0x2b, 0xe4, 0x3b, 0x1c, 0xae, 0xd6, 0xde, 0x4b, 0x6a, 0x5d,
	0x51, 0xbf, 0xdb, 0x85, 0xba, 0xde, 0x75, 0x45, 0xfe, 0x74, 0x55, 0xaf, 0x75, 0x42, 0xb0, 0x36,
	0xf5, 0x89, 0x05, 0x8d, 0x08, 0x65, 0x75, 0x82, 0x8a, 0x4f, 0xf2, 0x11, 0xf6, 0x56, 0x74, 0xb1,
	0xc4, 0xea, 0xf0, 0xbc, 0xda, 0x71, 0xc3, 0xf9, 0x25, 0xea, 0x54, 0x7f, 0xaf, 0x75, 0x22, 0x20,
	0xff, 0xba, 0x79, 0x44, 0xea, 0xd3, 0x43, 0xa9, 0xd7, 0x3b, 0xaf, 0x6a, 0x4d, 0xec, 0xec, 0xc3,
	0xb7, 0xd3, 0x90, 0x89, 0x1f, 0xcb, 0x99, 0x33, 0x4f, 0x63, 0xb7, 0xba, 0x40, 0x36, 0x18, 0xdc,
	0x79, 0x9a, 0xa3, 0x4b, 0x33, 0xe6, 0x6e, 0x5c, 0x4f, 0xb3, 0xa6, 0x7a, 0x1d, 0xff, 0x0d, 0x00,
	0x00, 0xff, 0xff, 0xb4, 0x3f, 0x14, 0x37, 0xb8, 0x04, 0x00, 0x00,
}
