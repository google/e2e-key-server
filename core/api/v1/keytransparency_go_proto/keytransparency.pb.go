// Code generated by protoc-gen-go. DO NOT EDIT.
// source: v1/keytransparency.proto

// Key Transparency
//
// The Key Transparency API consists of a map of user names to public
// keys. Each user name also has a history of public keys that have been
// associated with it.

package keytransparency_go_proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	trillian "github.com/google/trillian"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Committed represents the data committed to in a cryptographic commitment.
// commitment = HMAC_SHA512_256(key, data)
type Committed struct {
	// key is the 16 byte random commitment key.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// data is the data being committed to.
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Committed) Reset()         { *m = Committed{} }
func (m *Committed) String() string { return proto.CompactTextString(m) }
func (*Committed) ProtoMessage()    {}
func (*Committed) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{0}
}

func (m *Committed) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Committed.Unmarshal(m, b)
}
func (m *Committed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Committed.Marshal(b, m, deterministic)
}
func (m *Committed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Committed.Merge(m, src)
}
func (m *Committed) XXX_Size() int {
	return xxx_messageInfo_Committed.Size(m)
}
func (m *Committed) XXX_DiscardUnknown() {
	xxx_messageInfo_Committed.DiscardUnknown(m)
}

var xxx_messageInfo_Committed proto.InternalMessageInfo

func (m *Committed) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Committed) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// EntryUpdate contains the user entry update(s).
// EntryUpdate will be placed in a Log of mutations.
type EntryUpdate struct {
	// user_id specifies the id for the user whose profile is being updated.
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// mutation authorizes the change to entry.
	Mutation *SignedEntry `protobuf:"bytes,2,opt,name=mutation,proto3" json:"mutation,omitempty"`
	// committed contains the data committed to in mutation.commitment.
	Committed            *Committed `protobuf:"bytes,3,opt,name=committed,proto3" json:"committed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *EntryUpdate) Reset()         { *m = EntryUpdate{} }
func (m *EntryUpdate) String() string { return proto.CompactTextString(m) }
func (*EntryUpdate) ProtoMessage()    {}
func (*EntryUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{1}
}

func (m *EntryUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EntryUpdate.Unmarshal(m, b)
}
func (m *EntryUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EntryUpdate.Marshal(b, m, deterministic)
}
func (m *EntryUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryUpdate.Merge(m, src)
}
func (m *EntryUpdate) XXX_Size() int {
	return xxx_messageInfo_EntryUpdate.Size(m)
}
func (m *EntryUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EntryUpdate proto.InternalMessageInfo

func (m *EntryUpdate) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *EntryUpdate) GetMutation() *SignedEntry {
	if m != nil {
		return m.Mutation
	}
	return nil
}

func (m *EntryUpdate) GetCommitted() *Committed {
	if m != nil {
		return m.Committed
	}
	return nil
}

// Entry is a signed change to a map entry.
// Entry contains a commitment to profile and a set of authorized update keys.
// Entry is placed in the verifiable map as leaf data.
type Entry struct {
	// index is the location of this leaf in the sparse merkle tree.
	Index []byte `protobuf:"bytes,3,opt,name=index,proto3" json:"index,omitempty"`
	// commitment is a cryptographic commitment to arbitrary data.
	Commitment []byte `protobuf:"bytes,6,opt,name=commitment,proto3" json:"commitment,omitempty"`
	// authorized_keys is the tink keyset that validates the signatures on the next entry.
	AuthorizedKeyset []byte `protobuf:"bytes,9,opt,name=authorized_keyset,json=authorizedKeyset,proto3" json:"authorized_keyset,omitempty"`
	// previous contains the SHA256 hash of SignedEntry.Entry the last time it was modified.
	Previous             []byte   `protobuf:"bytes,8,opt,name=previous,proto3" json:"previous,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{2}
}

func (m *Entry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Entry.Unmarshal(m, b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return xxx_messageInfo_Entry.Size(m)
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetIndex() []byte {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *Entry) GetCommitment() []byte {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *Entry) GetAuthorizedKeyset() []byte {
	if m != nil {
		return m.AuthorizedKeyset
	}
	return nil
}

func (m *Entry) GetPrevious() []byte {
	if m != nil {
		return m.Previous
	}
	return nil
}

// SignedEntry is a cryptographically signed Entry.
// SignedEntry will be storead as a trillian.Map leaf.
type SignedEntry struct {
	// entry contains a serialized Entry.
	Entry []byte `protobuf:"bytes,1,opt,name=entry,proto3" json:"entry,omitempty"`
	// signatures on entry. Must be signed by keys from both previous and
	// current revisions. The first proves ownership of new revision key, and the
	// second proves that the correct owner is making this change.
	// The signature scheme is specified by the authorized_keys tink.Keyset.
	Signatures           [][]byte `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignedEntry) Reset()         { *m = SignedEntry{} }
func (m *SignedEntry) String() string { return proto.CompactTextString(m) }
func (*SignedEntry) ProtoMessage()    {}
func (*SignedEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{3}
}

func (m *SignedEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignedEntry.Unmarshal(m, b)
}
func (m *SignedEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignedEntry.Marshal(b, m, deterministic)
}
func (m *SignedEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedEntry.Merge(m, src)
}
func (m *SignedEntry) XXX_Size() int {
	return xxx_messageInfo_SignedEntry.Size(m)
}
func (m *SignedEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SignedEntry proto.InternalMessageInfo

func (m *SignedEntry) GetEntry() []byte {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *SignedEntry) GetSignatures() [][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// MutationProof contains the information necessary to compute the new leaf
// value. It contains a) the old leaf value with it's inclusion proof and b) the
// mutation. The new leaf value is computed via:
//       Mutate(leaf_value, mutation)
type MutationProof struct {
	// mutation contains the information needed to modify the old leaf.
	// The format of a mutation is specific to the particular Mutate function
	// being used.
	Mutation *SignedEntry `protobuf:"bytes,1,opt,name=mutation,proto3" json:"mutation,omitempty"`
	// leaf_proof contains the leaf and its inclusion proof for a particular map
	// revision.
	LeafProof            *trillian.MapLeafInclusion `protobuf:"bytes,2,opt,name=leaf_proof,json=leafProof,proto3" json:"leaf_proof,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *MutationProof) Reset()         { *m = MutationProof{} }
func (m *MutationProof) String() string { return proto.CompactTextString(m) }
func (*MutationProof) ProtoMessage()    {}
func (*MutationProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{4}
}

func (m *MutationProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MutationProof.Unmarshal(m, b)
}
func (m *MutationProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MutationProof.Marshal(b, m, deterministic)
}
func (m *MutationProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MutationProof.Merge(m, src)
}
func (m *MutationProof) XXX_Size() int {
	return xxx_messageInfo_MutationProof.Size(m)
}
func (m *MutationProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MutationProof.DiscardUnknown(m)
}

var xxx_messageInfo_MutationProof proto.InternalMessageInfo

func (m *MutationProof) GetMutation() *SignedEntry {
	if m != nil {
		return m.Mutation
	}
	return nil
}

func (m *MutationProof) GetLeafProof() *trillian.MapLeafInclusion {
	if m != nil {
		return m.LeafProof
	}
	return nil
}

// MapperMetadata tracks the mutations that have been mapped so far. It is
// embedded in the Trillian SignedMapHead.
type MapperMetadata struct {
	HighestFullyCompletedSeq int64    `protobuf:"varint,1,opt,name=highest_fully_completed_seq,json=highestFullyCompletedSeq,proto3" json:"highest_fully_completed_seq,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *MapperMetadata) Reset()         { *m = MapperMetadata{} }
func (m *MapperMetadata) String() string { return proto.CompactTextString(m) }
func (*MapperMetadata) ProtoMessage()    {}
func (*MapperMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{5}
}

func (m *MapperMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MapperMetadata.Unmarshal(m, b)
}
func (m *MapperMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MapperMetadata.Marshal(b, m, deterministic)
}
func (m *MapperMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapperMetadata.Merge(m, src)
}
func (m *MapperMetadata) XXX_Size() int {
	return xxx_messageInfo_MapperMetadata.Size(m)
}
func (m *MapperMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MapperMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MapperMetadata proto.InternalMessageInfo

func (m *MapperMetadata) GetHighestFullyCompletedSeq() int64 {
	if m != nil {
		return m.HighestFullyCompletedSeq
	}
	return 0
}

// Gets the leaf entry for a user.
type GetUserRequest struct {
	// directory_id identifies the directory in which the user lives.
	DirectoryId string `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// user_id is the user identifier, the format for which is defined by the
	// application.
	UserId string `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// last_verified_tree_size is the tree_size of the last log root the client
	// verified. Omitting this field will omit the log consistency proof from the
	// response.
	LastVerifiedTreeSize int64    `protobuf:"varint,3,opt,name=last_verified_tree_size,json=lastVerifiedTreeSize,proto3" json:"last_verified_tree_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserRequest) Reset()         { *m = GetUserRequest{} }
func (m *GetUserRequest) String() string { return proto.CompactTextString(m) }
func (*GetUserRequest) ProtoMessage()    {}
func (*GetUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{6}
}

func (m *GetUserRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetUserRequest.Unmarshal(m, b)
}
func (m *GetUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetUserRequest.Marshal(b, m, deterministic)
}
func (m *GetUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserRequest.Merge(m, src)
}
func (m *GetUserRequest) XXX_Size() int {
	return xxx_messageInfo_GetUserRequest.Size(m)
}
func (m *GetUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserRequest proto.InternalMessageInfo

func (m *GetUserRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *GetUserRequest) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *GetUserRequest) GetLastVerifiedTreeSize() int64 {
	if m != nil {
		return m.LastVerifiedTreeSize
	}
	return 0
}

// Leaf entry for a user.
type MapLeaf struct {
	// vrf_proof is the proof for the VRF on user_id.
	VrfProof []byte `protobuf:"bytes,1,opt,name=vrf_proof,json=vrfProof,proto3" json:"vrf_proof,omitempty"`
	// map_inclusion is an inclusion proof for the map leaf in an accompanying
	// trillian.SignedMapRoot. If the leaf is non-empty, its leaf.leaf_value
	// stores a serialized Entry proto.
	MapInclusion *trillian.MapLeafInclusion `protobuf:"bytes,2,opt,name=map_inclusion,json=mapInclusion,proto3" json:"map_inclusion,omitempty"`
	// committed contains the data and nonce used to make a cryptographic
	// commitment, which is stored in the commitment field of the serialized Entry
	// proto from map_inclusion.
	// Note: committed can also be found serialized in
	// map_inclusion.leaf.extra_data.
	Committed            *Committed `protobuf:"bytes,3,opt,name=committed,proto3" json:"committed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MapLeaf) Reset()         { *m = MapLeaf{} }
func (m *MapLeaf) String() string { return proto.CompactTextString(m) }
func (*MapLeaf) ProtoMessage()    {}
func (*MapLeaf) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{7}
}

func (m *MapLeaf) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MapLeaf.Unmarshal(m, b)
}
func (m *MapLeaf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MapLeaf.Marshal(b, m, deterministic)
}
func (m *MapLeaf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapLeaf.Merge(m, src)
}
func (m *MapLeaf) XXX_Size() int {
	return xxx_messageInfo_MapLeaf.Size(m)
}
func (m *MapLeaf) XXX_DiscardUnknown() {
	xxx_messageInfo_MapLeaf.DiscardUnknown(m)
}

var xxx_messageInfo_MapLeaf proto.InternalMessageInfo

func (m *MapLeaf) GetVrfProof() []byte {
	if m != nil {
		return m.VrfProof
	}
	return nil
}

func (m *MapLeaf) GetMapInclusion() *trillian.MapLeafInclusion {
	if m != nil {
		return m.MapInclusion
	}
	return nil
}

func (m *MapLeaf) GetCommitted() *Committed {
	if m != nil {
		return m.Committed
	}
	return nil
}

// Contains the leaf entry for a user at the most recently published revision.
type GetUserResponse struct {
	// revision is the most recently published revision.
	Revision *Revision `protobuf:"bytes,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// leaf is the leaf entry for the requested user.
	Leaf                 *MapLeaf `protobuf:"bytes,2,opt,name=leaf,proto3" json:"leaf,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserResponse) Reset()         { *m = GetUserResponse{} }
func (m *GetUserResponse) String() string { return proto.CompactTextString(m) }
func (*GetUserResponse) ProtoMessage()    {}
func (*GetUserResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{8}
}

func (m *GetUserResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetUserResponse.Unmarshal(m, b)
}
func (m *GetUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetUserResponse.Marshal(b, m, deterministic)
}
func (m *GetUserResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserResponse.Merge(m, src)
}
func (m *GetUserResponse) XXX_Size() int {
	return xxx_messageInfo_GetUserResponse.Size(m)
}
func (m *GetUserResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserResponse proto.InternalMessageInfo

func (m *GetUserResponse) GetRevision() *Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *GetUserResponse) GetLeaf() *MapLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

// BatchGetUserRequest contains multiple user_ids to fetch.
type BatchGetUserRequest struct {
	// directory_id identifies the directory in which the users live.
	DirectoryId string `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// user_ids are the user identifiers, the format for which is defined by the
	// application.
	UserIds []string `protobuf:"bytes,2,rep,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
	// last_verified_tree_size is the tree_size of the last log root the client
	// verified. Omitting this field will omit the log consistency proof from the
	// response.
	LastVerifiedTreeSize int64    `protobuf:"varint,3,opt,name=last_verified_tree_size,json=lastVerifiedTreeSize,proto3" json:"last_verified_tree_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchGetUserRequest) Reset()         { *m = BatchGetUserRequest{} }
func (m *BatchGetUserRequest) String() string { return proto.CompactTextString(m) }
func (*BatchGetUserRequest) ProtoMessage()    {}
func (*BatchGetUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{9}
}

func (m *BatchGetUserRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchGetUserRequest.Unmarshal(m, b)
}
func (m *BatchGetUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchGetUserRequest.Marshal(b, m, deterministic)
}
func (m *BatchGetUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchGetUserRequest.Merge(m, src)
}
func (m *BatchGetUserRequest) XXX_Size() int {
	return xxx_messageInfo_BatchGetUserRequest.Size(m)
}
func (m *BatchGetUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchGetUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchGetUserRequest proto.InternalMessageInfo

func (m *BatchGetUserRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *BatchGetUserRequest) GetUserIds() []string {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *BatchGetUserRequest) GetLastVerifiedTreeSize() int64 {
	if m != nil {
		return m.LastVerifiedTreeSize
	}
	return 0
}

// BatchGetUserIndexRequest identifies a set of users.
type BatchGetUserIndexRequest struct {
	// directory_id identifies the directory in which the users live.
	DirectoryId string `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// user_ids are the user identifiers
	UserIds              []string `protobuf:"bytes,2,rep,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchGetUserIndexRequest) Reset()         { *m = BatchGetUserIndexRequest{} }
func (m *BatchGetUserIndexRequest) String() string { return proto.CompactTextString(m) }
func (*BatchGetUserIndexRequest) ProtoMessage()    {}
func (*BatchGetUserIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{10}
}

func (m *BatchGetUserIndexRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchGetUserIndexRequest.Unmarshal(m, b)
}
func (m *BatchGetUserIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchGetUserIndexRequest.Marshal(b, m, deterministic)
}
func (m *BatchGetUserIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchGetUserIndexRequest.Merge(m, src)
}
func (m *BatchGetUserIndexRequest) XXX_Size() int {
	return xxx_messageInfo_BatchGetUserIndexRequest.Size(m)
}
func (m *BatchGetUserIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchGetUserIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchGetUserIndexRequest proto.InternalMessageInfo

func (m *BatchGetUserIndexRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *BatchGetUserIndexRequest) GetUserIds() []string {
	if m != nil {
		return m.UserIds
	}
	return nil
}

// BatchGetUserIndexRequest identifies a single user.
type BatchGetUserIndexResponse struct {
	// proofs is a map from user_id to its VRF proof.
	// Clients get the index by verifying the VRF proof.
	Proofs               map[string][]byte `protobuf:"bytes,1,rep,name=proofs,proto3" json:"proofs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BatchGetUserIndexResponse) Reset()         { *m = BatchGetUserIndexResponse{} }
func (m *BatchGetUserIndexResponse) String() string { return proto.CompactTextString(m) }
func (*BatchGetUserIndexResponse) ProtoMessage()    {}
func (*BatchGetUserIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{11}
}

func (m *BatchGetUserIndexResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchGetUserIndexResponse.Unmarshal(m, b)
}
func (m *BatchGetUserIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchGetUserIndexResponse.Marshal(b, m, deterministic)
}
func (m *BatchGetUserIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchGetUserIndexResponse.Merge(m, src)
}
func (m *BatchGetUserIndexResponse) XXX_Size() int {
	return xxx_messageInfo_BatchGetUserIndexResponse.Size(m)
}
func (m *BatchGetUserIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchGetUserIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchGetUserIndexResponse proto.InternalMessageInfo

func (m *BatchGetUserIndexResponse) GetProofs() map[string][]byte {
	if m != nil {
		return m.Proofs
	}
	return nil
}

// BatchGetUserResponse contains the leaf entries for a set of users at the most
// recently published revision.
type BatchGetUserResponse struct {
	// revision is the most recently published revision.
	Revision *Revision `protobuf:"bytes,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// map_leaves_by_user_id is a map from user_id to the map leaf at the most
	// recently published revision.
	MapLeavesByUserId    map[string]*MapLeaf `protobuf:"bytes,2,rep,name=map_leaves_by_user_id,json=mapLeavesByUserId,proto3" json:"map_leaves_by_user_id,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BatchGetUserResponse) Reset()         { *m = BatchGetUserResponse{} }
func (m *BatchGetUserResponse) String() string { return proto.CompactTextString(m) }
func (*BatchGetUserResponse) ProtoMessage()    {}
func (*BatchGetUserResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{12}
}

func (m *BatchGetUserResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchGetUserResponse.Unmarshal(m, b)
}
func (m *BatchGetUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchGetUserResponse.Marshal(b, m, deterministic)
}
func (m *BatchGetUserResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchGetUserResponse.Merge(m, src)
}
func (m *BatchGetUserResponse) XXX_Size() int {
	return xxx_messageInfo_BatchGetUserResponse.Size(m)
}
func (m *BatchGetUserResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchGetUserResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchGetUserResponse proto.InternalMessageInfo

func (m *BatchGetUserResponse) GetRevision() *Revision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *BatchGetUserResponse) GetMapLeavesByUserId() map[string]*MapLeaf {
	if m != nil {
		return m.MapLeavesByUserId
	}
	return nil
}

// ListEntryHistoryRequest gets a list of historical keys for a user.
type ListEntryHistoryRequest struct {
	// directory_id identifies the directory in which the user lives.
	DirectoryId string `protobuf:"bytes,6,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// user_id is the user identifier.
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// start is the starting revision.
	Start int64 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	// page_size is the maximum number of entries to return.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// last_verified_tree_size is the tree_size of the last log root the client
	// verified. Omitting this field will omit the log consistency proof from the
	// response.
	LastVerifiedTreeSize int64    `protobuf:"varint,5,opt,name=last_verified_tree_size,json=lastVerifiedTreeSize,proto3" json:"last_verified_tree_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListEntryHistoryRequest) Reset()         { *m = ListEntryHistoryRequest{} }
func (m *ListEntryHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*ListEntryHistoryRequest) ProtoMessage()    {}
func (*ListEntryHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{13}
}

func (m *ListEntryHistoryRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListEntryHistoryRequest.Unmarshal(m, b)
}
func (m *ListEntryHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListEntryHistoryRequest.Marshal(b, m, deterministic)
}
func (m *ListEntryHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListEntryHistoryRequest.Merge(m, src)
}
func (m *ListEntryHistoryRequest) XXX_Size() int {
	return xxx_messageInfo_ListEntryHistoryRequest.Size(m)
}
func (m *ListEntryHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListEntryHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListEntryHistoryRequest proto.InternalMessageInfo

func (m *ListEntryHistoryRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *ListEntryHistoryRequest) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *ListEntryHistoryRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ListEntryHistoryRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListEntryHistoryRequest) GetLastVerifiedTreeSize() int64 {
	if m != nil {
		return m.LastVerifiedTreeSize
	}
	return 0
}

// ListEntryHistoryResponse requests a paginated history of keys for a user.
type ListEntryHistoryResponse struct {
	// values represents the list of keys this user_id has contained over time.
	Values []*GetUserResponse `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	// next_start is the next page token to query for pagination.
	// next_start is 0 when there are no more results to fetch.
	NextStart            int64    `protobuf:"varint,2,opt,name=next_start,json=nextStart,proto3" json:"next_start,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListEntryHistoryResponse) Reset()         { *m = ListEntryHistoryResponse{} }
func (m *ListEntryHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*ListEntryHistoryResponse) ProtoMessage()    {}
func (*ListEntryHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{14}
}

func (m *ListEntryHistoryResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListEntryHistoryResponse.Unmarshal(m, b)
}
func (m *ListEntryHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListEntryHistoryResponse.Marshal(b, m, deterministic)
}
func (m *ListEntryHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListEntryHistoryResponse.Merge(m, src)
}
func (m *ListEntryHistoryResponse) XXX_Size() int {
	return xxx_messageInfo_ListEntryHistoryResponse.Size(m)
}
func (m *ListEntryHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListEntryHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListEntryHistoryResponse proto.InternalMessageInfo

func (m *ListEntryHistoryResponse) GetValues() []*GetUserResponse {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *ListEntryHistoryResponse) GetNextStart() int64 {
	if m != nil {
		return m.NextStart
	}
	return 0
}

// ListUserRevisionsRequest gets a list of historical keys for a user.
type ListUserRevisionsRequest struct {
	// directory_id identifies the directory in which the user lives.
	DirectoryId string `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// user_id is the user identifier.
	UserId string `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// start_revision is the starting epoch.
	StartRevision int64 `protobuf:"varint,3,opt,name=start_revision,json=startRevision,proto3" json:"start_revision,omitempty"`
	// end_revision is the ending epoch.
	EndRevision int64 `protobuf:"varint,4,opt,name=end_revision,json=endRevision,proto3" json:"end_revision,omitempty"`
	// page_size is the maximum number of entries to return. If page_size is
	// unspecified, the server will decide how to paginate results.
	PageSize int32 `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// page_token is a continuation token for paginating through results.
	PageToken string `protobuf:"bytes,6,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// last_verified_tree_size is the tree_size of the last log root the client
	// verified. Omitting this field will omit the log consistency proof from the
	// response.
	LastVerifiedTreeSize int64    `protobuf:"varint,7,opt,name=last_verified_tree_size,json=lastVerifiedTreeSize,proto3" json:"last_verified_tree_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUserRevisionsRequest) Reset()         { *m = ListUserRevisionsRequest{} }
func (m *ListUserRevisionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListUserRevisionsRequest) ProtoMessage()    {}
func (*ListUserRevisionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{15}
}

func (m *ListUserRevisionsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUserRevisionsRequest.Unmarshal(m, b)
}
func (m *ListUserRevisionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUserRevisionsRequest.Marshal(b, m, deterministic)
}
func (m *ListUserRevisionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserRevisionsRequest.Merge(m, src)
}
func (m *ListUserRevisionsRequest) XXX_Size() int {
	return xxx_messageInfo_ListUserRevisionsRequest.Size(m)
}
func (m *ListUserRevisionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserRevisionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserRevisionsRequest proto.InternalMessageInfo

func (m *ListUserRevisionsRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *ListUserRevisionsRequest) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *ListUserRevisionsRequest) GetStartRevision() int64 {
	if m != nil {
		return m.StartRevision
	}
	return 0
}

func (m *ListUserRevisionsRequest) GetEndRevision() int64 {
	if m != nil {
		return m.EndRevision
	}
	return 0
}

func (m *ListUserRevisionsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListUserRevisionsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListUserRevisionsRequest) GetLastVerifiedTreeSize() int64 {
	if m != nil {
		return m.LastVerifiedTreeSize
	}
	return 0
}

// MapRevision contains a map leaf at a speific revision.
type MapRevision struct {
	// map_root contains the map root and its inclusion in the log.
	MapRoot *MapRoot `protobuf:"bytes,1,opt,name=map_root,json=mapRoot,proto3" json:"map_root,omitempty"`
	// map_leaf contains a leaf and its inclusion proof to map_root.
	MapLeaf              *MapLeaf `protobuf:"bytes,2,opt,name=map_leaf,json=mapLeaf,proto3" json:"map_leaf,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MapRevision) Reset()         { *m = MapRevision{} }
func (m *MapRevision) String() string { return proto.CompactTextString(m) }
func (*MapRevision) ProtoMessage()    {}
func (*MapRevision) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{16}
}

func (m *MapRevision) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MapRevision.Unmarshal(m, b)
}
func (m *MapRevision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MapRevision.Marshal(b, m, deterministic)
}
func (m *MapRevision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapRevision.Merge(m, src)
}
func (m *MapRevision) XXX_Size() int {
	return xxx_messageInfo_MapRevision.Size(m)
}
func (m *MapRevision) XXX_DiscardUnknown() {
	xxx_messageInfo_MapRevision.DiscardUnknown(m)
}

var xxx_messageInfo_MapRevision proto.InternalMessageInfo

func (m *MapRevision) GetMapRoot() *MapRoot {
	if m != nil {
		return m.MapRoot
	}
	return nil
}

func (m *MapRevision) GetMapLeaf() *MapLeaf {
	if m != nil {
		return m.MapLeaf
	}
	return nil
}

// ListUserRevisionsResponse requests a paginated history of keys for a user.
type ListUserRevisionsResponse struct {
	// latest_log_root contains the latest log root and its consistency proof.
	LatestLogRoot *LogRoot `protobuf:"bytes,1,opt,name=latest_log_root,json=latestLogRoot,proto3" json:"latest_log_root,omitempty"`
	// map_revisions represents the list of keys this user_id has contained over
	// time. At most page_size results will be returned.
	MapRevisions []*MapRevision `protobuf:"bytes,2,rep,name=map_revisions,json=mapRevisions,proto3" json:"map_revisions,omitempty"`
	// next_page_token is a pagination token which will be set if more than
	// page_size results are available. Clients can pass this value as
	// the page_token in the next request in order to continue pagination.
	NextPageToken        string   `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUserRevisionsResponse) Reset()         { *m = ListUserRevisionsResponse{} }
func (m *ListUserRevisionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListUserRevisionsResponse) ProtoMessage()    {}
func (*ListUserRevisionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{17}
}

func (m *ListUserRevisionsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUserRevisionsResponse.Unmarshal(m, b)
}
func (m *ListUserRevisionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUserRevisionsResponse.Marshal(b, m, deterministic)
}
func (m *ListUserRevisionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserRevisionsResponse.Merge(m, src)
}
func (m *ListUserRevisionsResponse) XXX_Size() int {
	return xxx_messageInfo_ListUserRevisionsResponse.Size(m)
}
func (m *ListUserRevisionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserRevisionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserRevisionsResponse proto.InternalMessageInfo

func (m *ListUserRevisionsResponse) GetLatestLogRoot() *LogRoot {
	if m != nil {
		return m.LatestLogRoot
	}
	return nil
}

func (m *ListUserRevisionsResponse) GetMapRevisions() []*MapRevision {
	if m != nil {
		return m.MapRevisions
	}
	return nil
}

func (m *ListUserRevisionsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// BatchListUserRevisionsRequest contains a list of users and a range of revisions.
type BatchListUserRevisionsRequest struct {
	// directory_id identifies the directory in which the users live.
	DirectoryId string `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// user_ids are the user identifiers.
	UserIds []string `protobuf:"bytes,2,rep,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
	// start_revision is the starting revision.
	StartRevision int64 `protobuf:"varint,3,opt,name=start_revision,json=startRevision,proto3" json:"start_revision,omitempty"`
	// end_revision is the ending epoch.
	EndRevision int64 `protobuf:"varint,4,opt,name=end_revision,json=endRevision,proto3" json:"end_revision,omitempty"`
	// page_size is the maximum number of entries to return. If page_size is
	// unspecified, the server will decide how to paginate results.
	PageSize int32 `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// page_token is a continuation token for paginating through results.
	PageToken string `protobuf:"bytes,6,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// last_verified_tree_size is the tree_size of the last log root the client
	// verified. Omitting this field will omit the log consistency proof from the
	// response.
	LastVerifiedTreeSize int64    `protobuf:"varint,7,opt,name=last_verified_tree_size,json=lastVerifiedTreeSize,proto3" json:"last_verified_tree_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchListUserRevisionsRequest) Reset()         { *m = BatchListUserRevisionsRequest{} }
func (m *BatchListUserRevisionsRequest) String() string { return proto.CompactTextString(m) }
func (*BatchListUserRevisionsRequest) ProtoMessage()    {}
func (*BatchListUserRevisionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{18}
}

func (m *BatchListUserRevisionsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchListUserRevisionsRequest.Unmarshal(m, b)
}
func (m *BatchListUserRevisionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchListUserRevisionsRequest.Marshal(b, m, deterministic)
}
func (m *BatchListUserRevisionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchListUserRevisionsRequest.Merge(m, src)
}
func (m *BatchListUserRevisionsRequest) XXX_Size() int {
	return xxx_messageInfo_BatchListUserRevisionsRequest.Size(m)
}
func (m *BatchListUserRevisionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchListUserRevisionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchListUserRevisionsRequest proto.InternalMessageInfo

func (m *BatchListUserRevisionsRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *BatchListUserRevisionsRequest) GetUserIds() []string {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *BatchListUserRevisionsRequest) GetStartRevision() int64 {
	if m != nil {
		return m.StartRevision
	}
	return 0
}

func (m *BatchListUserRevisionsRequest) GetEndRevision() int64 {
	if m != nil {
		return m.EndRevision
	}
	return 0
}

func (m *BatchListUserRevisionsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *BatchListUserRevisionsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *BatchListUserRevisionsRequest) GetLastVerifiedTreeSize() int64 {
	if m != nil {
		return m.LastVerifiedTreeSize
	}
	return 0
}

// BatchMapRevision contains a set of map leaves at a speific revision.
type BatchMapRevision struct {
	// map_root contains the map root and its inclusion in the log.
	MapRoot *MapRoot `protobuf:"bytes,1,opt,name=map_root,json=mapRoot,proto3" json:"map_root,omitempty"`
	// map_leaves_by_user_id contains a mapping from user_id to the map leaf at
	// this revision.
	MapLeavesByUserId    map[string]*MapLeaf `protobuf:"bytes,2,rep,name=map_leaves_by_user_id,json=mapLeavesByUserId,proto3" json:"map_leaves_by_user_id,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BatchMapRevision) Reset()         { *m = BatchMapRevision{} }
func (m *BatchMapRevision) String() string { return proto.CompactTextString(m) }
func (*BatchMapRevision) ProtoMessage()    {}
func (*BatchMapRevision) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{19}
}

func (m *BatchMapRevision) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchMapRevision.Unmarshal(m, b)
}
func (m *BatchMapRevision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchMapRevision.Marshal(b, m, deterministic)
}
func (m *BatchMapRevision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchMapRevision.Merge(m, src)
}
func (m *BatchMapRevision) XXX_Size() int {
	return xxx_messageInfo_BatchMapRevision.Size(m)
}
func (m *BatchMapRevision) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchMapRevision.DiscardUnknown(m)
}

var xxx_messageInfo_BatchMapRevision proto.InternalMessageInfo

func (m *BatchMapRevision) GetMapRoot() *MapRoot {
	if m != nil {
		return m.MapRoot
	}
	return nil
}

func (m *BatchMapRevision) GetMapLeavesByUserId() map[string]*MapLeaf {
	if m != nil {
		return m.MapLeavesByUserId
	}
	return nil
}

// BatchListUserRevisionsResponse contains multiple map leaves across multiple revisions.
type BatchListUserRevisionsResponse struct {
	// latest_log_root contains the latest log root and its consistency proof.
	LatestLogRoot *LogRoot `protobuf:"bytes,1,opt,name=latest_log_root,json=latestLogRoot,proto3" json:"latest_log_root,omitempty"`
	// map_revisions is a list of map revisions.  At most page_size revisions will be returned.
	MapRevisions         []*BatchMapRevision `protobuf:"bytes,2,rep,name=map_revisions,json=mapRevisions,proto3" json:"map_revisions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BatchListUserRevisionsResponse) Reset()         { *m = BatchListUserRevisionsResponse{} }
func (m *BatchListUserRevisionsResponse) String() string { return proto.CompactTextString(m) }
func (*BatchListUserRevisionsResponse) ProtoMessage()    {}
func (*BatchListUserRevisionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{20}
}

func (m *BatchListUserRevisionsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchListUserRevisionsResponse.Unmarshal(m, b)
}
func (m *BatchListUserRevisionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchListUserRevisionsResponse.Marshal(b, m, deterministic)
}
func (m *BatchListUserRevisionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchListUserRevisionsResponse.Merge(m, src)
}
func (m *BatchListUserRevisionsResponse) XXX_Size() int {
	return xxx_messageInfo_BatchListUserRevisionsResponse.Size(m)
}
func (m *BatchListUserRevisionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchListUserRevisionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchListUserRevisionsResponse proto.InternalMessageInfo

func (m *BatchListUserRevisionsResponse) GetLatestLogRoot() *LogRoot {
	if m != nil {
		return m.LatestLogRoot
	}
	return nil
}

func (m *BatchListUserRevisionsResponse) GetMapRevisions() []*BatchMapRevision {
	if m != nil {
		return m.MapRevisions
	}
	return nil
}

// UpdateEntryRequest updates a user's profile.
type UpdateEntryRequest struct {
	// directory_id identifies the directory in which the user lives.
	DirectoryId string `protobuf:"bytes,5,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// entry_update contains the user submitted update.
	EntryUpdate          *EntryUpdate `protobuf:"bytes,4,opt,name=entry_update,json=entryUpdate,proto3" json:"entry_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UpdateEntryRequest) Reset()         { *m = UpdateEntryRequest{} }
func (m *UpdateEntryRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateEntryRequest) ProtoMessage()    {}
func (*UpdateEntryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{21}
}

func (m *UpdateEntryRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateEntryRequest.Unmarshal(m, b)
}
func (m *UpdateEntryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateEntryRequest.Marshal(b, m, deterministic)
}
func (m *UpdateEntryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateEntryRequest.Merge(m, src)
}
func (m *UpdateEntryRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateEntryRequest.Size(m)
}
func (m *UpdateEntryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateEntryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateEntryRequest proto.InternalMessageInfo

func (m *UpdateEntryRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *UpdateEntryRequest) GetEntryUpdate() *EntryUpdate {
	if m != nil {
		return m.EntryUpdate
	}
	return nil
}

// BatchQueueUserUpdateRequest enqueues multiple changes to user profiles.
type BatchQueueUserUpdateRequest struct {
	// directory_id identifies the directory in which the users live.
	DirectoryId string `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// updates contains user updates.
	Updates              []*EntryUpdate `protobuf:"bytes,2,rep,name=updates,proto3" json:"updates,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchQueueUserUpdateRequest) Reset()         { *m = BatchQueueUserUpdateRequest{} }
func (m *BatchQueueUserUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*BatchQueueUserUpdateRequest) ProtoMessage()    {}
func (*BatchQueueUserUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{22}
}

func (m *BatchQueueUserUpdateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchQueueUserUpdateRequest.Unmarshal(m, b)
}
func (m *BatchQueueUserUpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchQueueUserUpdateRequest.Marshal(b, m, deterministic)
}
func (m *BatchQueueUserUpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchQueueUserUpdateRequest.Merge(m, src)
}
func (m *BatchQueueUserUpdateRequest) XXX_Size() int {
	return xxx_messageInfo_BatchQueueUserUpdateRequest.Size(m)
}
func (m *BatchQueueUserUpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchQueueUserUpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchQueueUserUpdateRequest proto.InternalMessageInfo

func (m *BatchQueueUserUpdateRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *BatchQueueUserUpdateRequest) GetUpdates() []*EntryUpdate {
	if m != nil {
		return m.Updates
	}
	return nil
}

// GetRevisionRequest identifies a particular revision.
type GetRevisionRequest struct {
	// directory_id is the directory for which revisions are being requested.
	DirectoryId string `protobuf:"bytes,5,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// revision specifies the revision number in which mutations will be returned.
	Revision int64 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// last_verified_tree_size is the tree_size of the last log root the client
	// verified. Omitting this field will omit the log consistency proof from the
	// response.
	LastVerifiedTreeSize int64    `protobuf:"varint,2,opt,name=last_verified_tree_size,json=lastVerifiedTreeSize,proto3" json:"last_verified_tree_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRevisionRequest) Reset()         { *m = GetRevisionRequest{} }
func (m *GetRevisionRequest) String() string { return proto.CompactTextString(m) }
func (*GetRevisionRequest) ProtoMessage()    {}
func (*GetRevisionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{23}
}

func (m *GetRevisionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetRevisionRequest.Unmarshal(m, b)
}
func (m *GetRevisionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetRevisionRequest.Marshal(b, m, deterministic)
}
func (m *GetRevisionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRevisionRequest.Merge(m, src)
}
func (m *GetRevisionRequest) XXX_Size() int {
	return xxx_messageInfo_GetRevisionRequest.Size(m)
}
func (m *GetRevisionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRevisionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRevisionRequest proto.InternalMessageInfo

func (m *GetRevisionRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *GetRevisionRequest) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *GetRevisionRequest) GetLastVerifiedTreeSize() int64 {
	if m != nil {
		return m.LastVerifiedTreeSize
	}
	return 0
}

// GetLatestRevisionRequest identifies a particular revision.
type GetLatestRevisionRequest struct {
	// directory_id is the directory for which revisions are being requested.
	DirectoryId string `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// last_verified_tree_size is the tree_size of the last log root the client
	// verified. Omitting this field will omit the log consistency proof from the
	// response.
	LastVerifiedTreeSize int64    `protobuf:"varint,2,opt,name=last_verified_tree_size,json=lastVerifiedTreeSize,proto3" json:"last_verified_tree_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLatestRevisionRequest) Reset()         { *m = GetLatestRevisionRequest{} }
func (m *GetLatestRevisionRequest) String() string { return proto.CompactTextString(m) }
func (*GetLatestRevisionRequest) ProtoMessage()    {}
func (*GetLatestRevisionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{24}
}

func (m *GetLatestRevisionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLatestRevisionRequest.Unmarshal(m, b)
}
func (m *GetLatestRevisionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLatestRevisionRequest.Marshal(b, m, deterministic)
}
func (m *GetLatestRevisionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLatestRevisionRequest.Merge(m, src)
}
func (m *GetLatestRevisionRequest) XXX_Size() int {
	return xxx_messageInfo_GetLatestRevisionRequest.Size(m)
}
func (m *GetLatestRevisionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLatestRevisionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLatestRevisionRequest proto.InternalMessageInfo

func (m *GetLatestRevisionRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *GetLatestRevisionRequest) GetLastVerifiedTreeSize() int64 {
	if m != nil {
		return m.LastVerifiedTreeSize
	}
	return 0
}

// MapRoot contains the map root and its inclusion proof in the log.
type MapRoot struct {
	// map_root contains the signed map root for the sparse Merkle Tree.
	MapRoot *trillian.SignedMapRoot `protobuf:"bytes,1,opt,name=map_root,json=mapRoot,proto3" json:"map_root,omitempty"`
	// log_inclusion proves that map_root is part of log_root at
	// index=map_root.MapRevision.
	LogInclusion         [][]byte `protobuf:"bytes,2,rep,name=log_inclusion,json=logInclusion,proto3" json:"log_inclusion,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MapRoot) Reset()         { *m = MapRoot{} }
func (m *MapRoot) String() string { return proto.CompactTextString(m) }
func (*MapRoot) ProtoMessage()    {}
func (*MapRoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{25}
}

func (m *MapRoot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MapRoot.Unmarshal(m, b)
}
func (m *MapRoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MapRoot.Marshal(b, m, deterministic)
}
func (m *MapRoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapRoot.Merge(m, src)
}
func (m *MapRoot) XXX_Size() int {
	return xxx_messageInfo_MapRoot.Size(m)
}
func (m *MapRoot) XXX_DiscardUnknown() {
	xxx_messageInfo_MapRoot.DiscardUnknown(m)
}

var xxx_messageInfo_MapRoot proto.InternalMessageInfo

func (m *MapRoot) GetMapRoot() *trillian.SignedMapRoot {
	if m != nil {
		return m.MapRoot
	}
	return nil
}

func (m *MapRoot) GetLogInclusion() [][]byte {
	if m != nil {
		return m.LogInclusion
	}
	return nil
}

// LogRootRequest contains the information needed to request and verify LogRoot.
type LogRootRequest struct {
	// root_hash is the root hash of the last log root the client verified.
	RootHash []byte `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	// tree_size is the tree size of the last log root the client verified.
	TreeSize             int64    `protobuf:"varint,2,opt,name=tree_size,json=treeSize,proto3" json:"tree_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogRootRequest) Reset()         { *m = LogRootRequest{} }
func (m *LogRootRequest) String() string { return proto.CompactTextString(m) }
func (*LogRootRequest) ProtoMessage()    {}
func (*LogRootRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{26}
}

func (m *LogRootRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogRootRequest.Unmarshal(m, b)
}
func (m *LogRootRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogRootRequest.Marshal(b, m, deterministic)
}
func (m *LogRootRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogRootRequest.Merge(m, src)
}
func (m *LogRootRequest) XXX_Size() int {
	return xxx_messageInfo_LogRootRequest.Size(m)
}
func (m *LogRootRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogRootRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogRootRequest proto.InternalMessageInfo

func (m *LogRootRequest) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *LogRootRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

// LogRoot contains the latest log root and its consistency proof.
type LogRoot struct {
	// log_root is the latest globally consistent log root.
	LogRoot *trillian.SignedLogRoot `protobuf:"bytes,1,opt,name=log_root,json=logRoot,proto3" json:"log_root,omitempty"`
	// log_consistency proves that log_root is consistent with previously seen
	// roots.
	LogConsistency       [][]byte `protobuf:"bytes,2,rep,name=log_consistency,json=logConsistency,proto3" json:"log_consistency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogRoot) Reset()         { *m = LogRoot{} }
func (m *LogRoot) String() string { return proto.CompactTextString(m) }
func (*LogRoot) ProtoMessage()    {}
func (*LogRoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{27}
}

func (m *LogRoot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LogRoot.Unmarshal(m, b)
}
func (m *LogRoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LogRoot.Marshal(b, m, deterministic)
}
func (m *LogRoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogRoot.Merge(m, src)
}
func (m *LogRoot) XXX_Size() int {
	return xxx_messageInfo_LogRoot.Size(m)
}
func (m *LogRoot) XXX_DiscardUnknown() {
	xxx_messageInfo_LogRoot.DiscardUnknown(m)
}

var xxx_messageInfo_LogRoot proto.InternalMessageInfo

func (m *LogRoot) GetLogRoot() *trillian.SignedLogRoot {
	if m != nil {
		return m.LogRoot
	}
	return nil
}

func (m *LogRoot) GetLogConsistency() [][]byte {
	if m != nil {
		return m.LogConsistency
	}
	return nil
}

// Revision represents a snapshot of the entire key directory and
// a diff of what changed between this revision and the previous revision.
type Revision struct {
	// directory_id is the directory identifier.
	DirectoryId string `protobuf:"bytes,1,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// map_root contains the map root and its inclusion in the log.
	MapRoot *MapRoot `protobuf:"bytes,5,opt,name=map_root,json=mapRoot,proto3" json:"map_root,omitempty"`
	// latest_log_root contains the most recent log root and its consistency
	// proof to the client's last seen log root.
	LatestLogRoot        *LogRoot `protobuf:"bytes,6,opt,name=latest_log_root,json=latestLogRoot,proto3" json:"latest_log_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Revision) Reset()         { *m = Revision{} }
func (m *Revision) String() string { return proto.CompactTextString(m) }
func (*Revision) ProtoMessage()    {}
func (*Revision) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{28}
}

func (m *Revision) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Revision.Unmarshal(m, b)
}
func (m *Revision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Revision.Marshal(b, m, deterministic)
}
func (m *Revision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Revision.Merge(m, src)
}
func (m *Revision) XXX_Size() int {
	return xxx_messageInfo_Revision.Size(m)
}
func (m *Revision) XXX_DiscardUnknown() {
	xxx_messageInfo_Revision.DiscardUnknown(m)
}

var xxx_messageInfo_Revision proto.InternalMessageInfo

func (m *Revision) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *Revision) GetMapRoot() *MapRoot {
	if m != nil {
		return m.MapRoot
	}
	return nil
}

func (m *Revision) GetLatestLogRoot() *LogRoot {
	if m != nil {
		return m.LatestLogRoot
	}
	return nil
}

// ListMutationsRequest requests the mutations that created a given revision.
type ListMutationsRequest struct {
	// directory_id is the directory identifier.
	DirectoryId string `protobuf:"bytes,5,opt,name=directory_id,json=directoryId,proto3" json:"directory_id,omitempty"`
	// revision specifies the revision number.
	Revision int64 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// page_token defines the starting point for pagination.
	// To request the next page, pass next_page_token from the previous response.
	// To start at the beginning, simply omit page_token from the request.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// page_size is the maximum number of mutations to return in a single request.
	// The server may choose a smaller page_size than the one requested.
	PageSize             int32    `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListMutationsRequest) Reset()         { *m = ListMutationsRequest{} }
func (m *ListMutationsRequest) String() string { return proto.CompactTextString(m) }
func (*ListMutationsRequest) ProtoMessage()    {}
func (*ListMutationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{29}
}

func (m *ListMutationsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListMutationsRequest.Unmarshal(m, b)
}
func (m *ListMutationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListMutationsRequest.Marshal(b, m, deterministic)
}
func (m *ListMutationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMutationsRequest.Merge(m, src)
}
func (m *ListMutationsRequest) XXX_Size() int {
	return xxx_messageInfo_ListMutationsRequest.Size(m)
}
func (m *ListMutationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMutationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListMutationsRequest proto.InternalMessageInfo

func (m *ListMutationsRequest) GetDirectoryId() string {
	if m != nil {
		return m.DirectoryId
	}
	return ""
}

func (m *ListMutationsRequest) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *ListMutationsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListMutationsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// ListMutationsResponse contains the mutations that produced an revision.
type ListMutationsResponse struct {
	// mutations contains the mutation object and the leaf value it operated on.
	Mutations []*MutationProof `protobuf:"bytes,6,rep,name=mutations,proto3" json:"mutations,omitempty"`
	// next_page_token is the next page token to query for pagination.
	// An empty value means there are no more results to fetch.
	NextPageToken        string   `protobuf:"bytes,7,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListMutationsResponse) Reset()         { *m = ListMutationsResponse{} }
func (m *ListMutationsResponse) String() string { return proto.CompactTextString(m) }
func (*ListMutationsResponse) ProtoMessage()    {}
func (*ListMutationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e925e13aa3e8f7d, []int{30}
}

func (m *ListMutationsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListMutationsResponse.Unmarshal(m, b)
}
func (m *ListMutationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListMutationsResponse.Marshal(b, m, deterministic)
}
func (m *ListMutationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMutationsResponse.Merge(m, src)
}
func (m *ListMutationsResponse) XXX_Size() int {
	return xxx_messageInfo_ListMutationsResponse.Size(m)
}
func (m *ListMutationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMutationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListMutationsResponse proto.InternalMessageInfo

func (m *ListMutationsResponse) GetMutations() []*MutationProof {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *ListMutationsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func init() {
	proto.RegisterType((*Committed)(nil), "google.keytransparency.v1.Committed")
	proto.RegisterType((*EntryUpdate)(nil), "google.keytransparency.v1.EntryUpdate")
	proto.RegisterType((*Entry)(nil), "google.keytransparency.v1.Entry")
	proto.RegisterType((*SignedEntry)(nil), "google.keytransparency.v1.SignedEntry")
	proto.RegisterType((*MutationProof)(nil), "google.keytransparency.v1.MutationProof")
	proto.RegisterType((*MapperMetadata)(nil), "google.keytransparency.v1.MapperMetadata")
	proto.RegisterType((*GetUserRequest)(nil), "google.keytransparency.v1.GetUserRequest")
	proto.RegisterType((*MapLeaf)(nil), "google.keytransparency.v1.MapLeaf")
	proto.RegisterType((*GetUserResponse)(nil), "google.keytransparency.v1.GetUserResponse")
	proto.RegisterType((*BatchGetUserRequest)(nil), "google.keytransparency.v1.BatchGetUserRequest")
	proto.RegisterType((*BatchGetUserIndexRequest)(nil), "google.keytransparency.v1.BatchGetUserIndexRequest")
	proto.RegisterType((*BatchGetUserIndexResponse)(nil), "google.keytransparency.v1.BatchGetUserIndexResponse")
	proto.RegisterMapType((map[string][]byte)(nil), "google.keytransparency.v1.BatchGetUserIndexResponse.ProofsEntry")
	proto.RegisterType((*BatchGetUserResponse)(nil), "google.keytransparency.v1.BatchGetUserResponse")
	proto.RegisterMapType((map[string]*MapLeaf)(nil), "google.keytransparency.v1.BatchGetUserResponse.MapLeavesByUserIdEntry")
	proto.RegisterType((*ListEntryHistoryRequest)(nil), "google.keytransparency.v1.ListEntryHistoryRequest")
	proto.RegisterType((*ListEntryHistoryResponse)(nil), "google.keytransparency.v1.ListEntryHistoryResponse")
	proto.RegisterType((*ListUserRevisionsRequest)(nil), "google.keytransparency.v1.ListUserRevisionsRequest")
	proto.RegisterType((*MapRevision)(nil), "google.keytransparency.v1.MapRevision")
	proto.RegisterType((*ListUserRevisionsResponse)(nil), "google.keytransparency.v1.ListUserRevisionsResponse")
	proto.RegisterType((*BatchListUserRevisionsRequest)(nil), "google.keytransparency.v1.BatchListUserRevisionsRequest")
	proto.RegisterType((*BatchMapRevision)(nil), "google.keytransparency.v1.BatchMapRevision")
	proto.RegisterMapType((map[string]*MapLeaf)(nil), "google.keytransparency.v1.BatchMapRevision.MapLeavesByUserIdEntry")
	proto.RegisterType((*BatchListUserRevisionsResponse)(nil), "google.keytransparency.v1.BatchListUserRevisionsResponse")
	proto.RegisterType((*UpdateEntryRequest)(nil), "google.keytransparency.v1.UpdateEntryRequest")
	proto.RegisterType((*BatchQueueUserUpdateRequest)(nil), "google.keytransparency.v1.BatchQueueUserUpdateRequest")
	proto.RegisterType((*GetRevisionRequest)(nil), "google.keytransparency.v1.GetRevisionRequest")
	proto.RegisterType((*GetLatestRevisionRequest)(nil), "google.keytransparency.v1.GetLatestRevisionRequest")
	proto.RegisterType((*MapRoot)(nil), "google.keytransparency.v1.MapRoot")
	proto.RegisterType((*LogRootRequest)(nil), "google.keytransparency.v1.LogRootRequest")
	proto.RegisterType((*LogRoot)(nil), "google.keytransparency.v1.LogRoot")
	proto.RegisterType((*Revision)(nil), "google.keytransparency.v1.Revision")
	proto.RegisterType((*ListMutationsRequest)(nil), "google.keytransparency.v1.ListMutationsRequest")
	proto.RegisterType((*ListMutationsResponse)(nil), "google.keytransparency.v1.ListMutationsResponse")
}

func init() { proto.RegisterFile("v1/keytransparency.proto", fileDescriptor_9e925e13aa3e8f7d) }

var fileDescriptor_9e925e13aa3e8f7d = []byte{
	// 1959 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0xcd, 0x8f, 0x1b, 0x49,
	0x15, 0x57, 0xf9, 0xdb, 0xcf, 0xf3, 0xe1, 0xa9, 0xcc, 0x26, 0x8e, 0x87, 0x44, 0xa1, 0x17, 0x42,
	0xc8, 0x6a, 0xdd, 0x99, 0xc9, 0x26, 0x3b, 0x19, 0x08, 0x59, 0x66, 0x36, 0x93, 0xcc, 0x64, 0x46,
	0x64, 0x7b, 0xb2, 0xb0, 0xe2, 0xd2, 0xea, 0xb1, 0x6b, 0xec, 0x56, 0xec, 0xee, 0x9e, 0xae, 0xb2,
	0x15, 0x27, 0xca, 0x65, 0x39, 0x20, 0x01, 0x42, 0x42, 0xcb, 0x01, 0x71, 0xe0, 0x80, 0x10, 0x17,
	0x24, 0x04, 0xdc, 0x60, 0x25, 0x04, 0x42, 0x5c, 0xb8, 0x21, 0xae, 0x1c, 0xf9, 0x43, 0x50, 0x7d,
	0x74, 0xbb, 0x6d, 0xb7, 0xdb, 0xf6, 0xec, 0xac, 0x04, 0x27, 0xbb, 0xaa, 0xeb, 0xbd, 0xfe, 0xbd,
	0xf7, 0x7e, 0xef, 0x55, 0xbd, 0x6a, 0xa8, 0xf4, 0xd6, 0xf5, 0xe7, 0xa4, 0xcf, 0x7c, 0xcb, 0xa1,
	0x9e, 0xe5, 0x13, 0xa7, 0xde, 0xaf, 0x79, 0xbe, 0xcb, 0x5c, 0x7c, 0xb9, 0xe9, 0xba, 0xcd, 0x36,
	0xa9, 0x8d, 0x3e, 0xed, 0xad, 0x57, 0xbf, 0x20, 0x1f, 0xe9, 0x96, 0x67, 0xeb, 0x96, 0xe3, 0xb8,
	0xcc, 0x62, 0xb6, 0xeb, 0x50, 0x29, 0x58, 0x5d, 0x53, 0x4f, 0xc5, 0xe8, 0xb8, 0x7b, 0xa2, 0x93,
	0x8e, 0xc7, 0x94, 0xd6, 0xea, 0x12, 0xf3, 0xed, 0x76, 0xdb, 0xb6, 0x1c, 0x35, 0xbe, 0x18, 0x8c,
	0xcd, 0x8e, 0xe5, 0x99, 0x96, 0x67, 0x07, 0xeb, 0x7a, 0xeb, 0xba, 0xd5, 0xe8, 0xd8, 0x6a, 0x9d,
	0xb6, 0x0e, 0xc5, 0x1d, 0xb7, 0xd3, 0xb1, 0x19, 0x23, 0x0d, 0x5c, 0x86, 0xf4, 0x73, 0xd2, 0xaf,
	0xa0, 0x6b, 0xe8, 0xc6, 0x82, 0xc1, 0xff, 0x62, 0x0c, 0x99, 0x86, 0xc5, 0xac, 0x4a, 0x4a, 0x4c,
	0x89, 0xff, 0xda, 0x6f, 0x11, 0x94, 0x1e, 0x3a, 0xcc, 0xef, 0x7f, 0xe8, 0x35, 0x2c, 0x46, 0xf0,
	0x25, 0xc8, 0x77, 0x29, 0xf1, 0x4d, 0xbb, 0x21, 0x24, 0x8b, 0x46, 0x8e, 0x0f, 0xf7, 0x1a, 0x78,
	0x1b, 0x0a, 0x9d, 0xae, 0xb4, 0x41, 0x28, 0x28, 0x6d, 0x5c, 0xaf, 0x4d, 0x34, 0xbe, 0x76, 0x64,
	0x37, 0x1d, 0xd2, 0x10, 0x8a, 0x8d, 0x50, 0x0e, 0x6f, 0x43, 0xb1, 0x1e, 0xe0, 0xab, 0xa4, 0x85,
	0x92, 0x2f, 0x25, 0x28, 0x09, 0x6d, 0x31, 0x06, 0x62, 0xda, 0xaf, 0x10, 0x64, 0x85, 0x5e, 0xbc,
	0x0a, 0x59, 0xdb, 0x69, 0x90, 0x17, 0x42, 0xd3, 0x82, 0x21, 0x07, 0xf8, 0x2a, 0x80, 0x5c, 0xdc,
	0x21, 0x0e, 0xab, 0xe4, 0xc4, 0xa3, 0xc8, 0x0c, 0x7e, 0x0b, 0x56, 0xac, 0x2e, 0x6b, 0xb9, 0xbe,
	0xfd, 0x92, 0x34, 0xcc, 0xe7, 0xa4, 0x4f, 0x09, 0xab, 0x14, 0xc5, 0xb2, 0xf2, 0xe0, 0xc1, 0x13,
	0x31, 0x8f, 0xab, 0x50, 0xf0, 0x7c, 0xd2, 0xb3, 0xdd, 0x2e, 0xad, 0x14, 0xc4, 0x9a, 0x70, 0xbc,
	0x9f, 0x29, 0xa0, 0x72, 0x6a, 0x3f, 0x53, 0x48, 0x95, 0xd3, 0xfb, 0x99, 0x42, 0xa6, 0x9c, 0xdd,
	0xcf, 0x14, 0xb2, 0xe5, 0xdc, 0x7e, 0xa6, 0x90, 0x2f, 0x17, 0xb4, 0x1d, 0x28, 0x45, 0x7c, 0xc0,
	0xb1, 0x12, 0xfe, 0x47, 0x85, 0x43, 0x0e, 0x38, 0x56, 0x6a, 0x37, 0x1d, 0x8b, 0x75, 0x7d, 0x42,
	0x2b, 0xa9, 0x6b, 0x69, 0x8e, 0x75, 0x30, 0xa3, 0xfd, 0x18, 0xc1, 0xe2, 0xa1, 0x72, 0xde, 0x53,
	0xdf, 0x75, 0x4f, 0x86, 0xa2, 0x80, 0xce, 0x18, 0x85, 0x7b, 0x00, 0x6d, 0x62, 0x9d, 0x98, 0x1e,
	0xd7, 0xa8, 0x62, 0x59, 0xad, 0x85, 0x94, 0x3b, 0xb4, 0xbc, 0x03, 0x62, 0x9d, 0xec, 0x39, 0xf5,
	0x76, 0x97, 0xda, 0xae, 0x63, 0x14, 0xf9, 0x6a, 0xf1, 0x7a, 0xed, 0x5b, 0xb0, 0x74, 0x68, 0x79,
	0x1e, 0xf1, 0x0f, 0x09, 0xb3, 0x38, 0x7f, 0xf0, 0x7d, 0x58, 0x6b, 0xd9, 0xcd, 0x16, 0xa1, 0xcc,
	0x3c, 0xe9, 0xb6, 0xdb, 0x7d, 0xb3, 0xee, 0x76, 0xbc, 0x36, 0x61, 0xa4, 0x61, 0x52, 0x72, 0x2a,
	0x30, 0xa6, 0x8d, 0x8a, 0x5a, 0xb2, 0xcb, 0x57, 0xec, 0x04, 0x0b, 0x8e, 0xc8, 0xa9, 0xf6, 0x3d,
	0x04, 0x4b, 0x8f, 0x08, 0xfb, 0x90, 0x12, 0xdf, 0x20, 0xa7, 0x5d, 0x42, 0x19, 0xfe, 0x22, 0x2c,
	0x34, 0x6c, 0x9f, 0xd4, 0x99, 0xeb, 0xf7, 0x07, 0x34, 0x2c, 0x85, 0x73, 0x7b, 0x8d, 0x28, 0x49,
	0x53, 0x43, 0x24, 0xbd, 0x03, 0x97, 0xda, 0x16, 0x65, 0x66, 0x8f, 0xf8, 0xf6, 0x89, 0x4d, 0x1a,
	0x26, 0xf3, 0x09, 0x31, 0xa9, 0xfd, 0x92, 0x08, 0x92, 0xa4, 0x8d, 0x55, 0xfe, 0xf8, 0xdb, 0xea,
	0xe9, 0x33, 0x9f, 0x90, 0x23, 0xfb, 0x25, 0xd1, 0x7e, 0x83, 0x20, 0xaf, 0xcc, 0xc6, 0x6b, 0x50,
	0xec, 0xf9, 0x81, 0x73, 0x64, 0xb4, 0x0a, 0x3d, 0x5f, 0xda, 0x8f, 0x1f, 0xc0, 0x22, 0xcf, 0x40,
	0x3b, 0xf0, 0xcd, 0x0c, 0xde, 0x5b, 0xe8, 0x58, 0x5e, 0x38, 0x3a, 0x97, 0x0c, 0xf8, 0x01, 0x82,
	0xe5, 0xd0, 0x67, 0xd4, 0x73, 0x1d, 0x4a, 0xf0, 0x03, 0x28, 0x70, 0x5e, 0xd2, 0x01, 0x2f, 0xde,
	0x4c, 0x50, 0x6b, 0xa8, 0xa5, 0x46, 0x28, 0x84, 0xef, 0x42, 0x86, 0x87, 0x59, 0x19, 0xa4, 0x25,
	0x08, 0x2b, 0x0b, 0x0d, 0xb1, 0x9e, 0x83, 0xb9, 0xb0, 0x6d, 0xb1, 0x7a, 0x6b, 0xfe, 0x28, 0x5e,
	0x86, 0x82, 0x8a, 0xa2, 0xe4, 0x7e, 0xd1, 0xc8, 0xcb, 0x30, 0xd2, 0xb3, 0xc6, 0xf1, 0x23, 0xa8,
	0x44, 0xb1, 0xec, 0xf1, 0x82, 0x70, 0x2e, 0x80, 0xb4, 0xdf, 0x21, 0xb8, 0x1c, 0xa3, 0x5a, 0x79,
	0xff, 0x23, 0xc8, 0x09, 0xbe, 0xd0, 0x0a, 0xba, 0x96, 0xbe, 0x51, 0xda, 0x78, 0x2f, 0xc1, 0x7d,
	0x13, 0xb5, 0xd4, 0x04, 0xc5, 0xa8, 0xcc, 0x56, 0xa5, 0xaf, 0x7a, 0x0f, 0x4a, 0x91, 0xe9, 0x68,
	0x4d, 0x2f, 0xca, 0x9a, 0xbe, 0x0a, 0xd9, 0x9e, 0xd5, 0xee, 0x12, 0x55, 0xd4, 0xe5, 0x60, 0x2b,
	0xb5, 0x89, 0xb4, 0x4f, 0x53, 0xb0, 0x3a, 0x1c, 0x99, 0xf3, 0xe2, 0xca, 0x0b, 0x78, 0x83, 0x67,
	0x41, 0x9b, 0x58, 0x3d, 0x42, 0xcd, 0xe3, 0xbe, 0x39, 0x48, 0x46, 0x6e, 0xfd, 0xee, 0x8c, 0xd6,
	0x87, 0x86, 0x4b, 0x46, 0xf5, 0x08, 0xdd, 0xee, 0x0b, 0xaf, 0xa8, 0x8a, 0xb5, 0xd2, 0x19, 0x9d,
	0xaf, 0xb6, 0xe0, 0x62, 0xfc, 0xe2, 0x18, 0xcf, 0x6c, 0x46, 0x3d, 0x33, 0x1b, 0xa5, 0x23, 0xde,
	0xfb, 0x3b, 0x82, 0x4b, 0x07, 0x36, 0x65, 0x42, 0xfb, 0x63, 0x9b, 0x72, 0x8a, 0x4c, 0xa2, 0x52,
	0x2e, 0xb1, 0x42, 0x0d, 0x6f, 0xa3, 0xab, 0x90, 0xa5, 0xcc, 0xf2, 0x99, 0x40, 0x95, 0x36, 0xe4,
	0x80, 0x17, 0x1d, 0xcf, 0x6a, 0x46, 0x18, 0x9e, 0x35, 0x0a, 0x7c, 0x82, 0xb3, 0x3a, 0x29, 0x19,
	0xb2, 0x93, 0x93, 0x41, 0xee, 0x49, 0xda, 0x6b, 0xa8, 0x8c, 0x9b, 0xa1, 0x88, 0xb0, 0x0d, 0x39,
	0x61, 0x70, 0x40, 0xdb, 0x9b, 0x09, 0x2e, 0x1a, 0x89, 0x99, 0xa1, 0x24, 0xf1, 0x15, 0x00, 0x87,
	0xbc, 0x60, 0x66, 0xd4, 0xa8, 0x22, 0x9f, 0x39, 0xe2, 0x13, 0xda, 0x27, 0x29, 0xf9, 0x7e, 0x29,
	0x2b, 0xf9, 0x43, 0xcf, 0xa3, 0xd2, 0x7f, 0x19, 0x96, 0xc4, 0x2b, 0xcd, 0x90, 0xca, 0xb2, 0x30,
	0x2c, 0x8a, 0xd9, 0xe0, 0x55, 0xfc, 0x15, 0xc4, 0x69, 0x0c, 0x16, 0x65, 0xc4, 0xa2, 0x12, 0x71,
	0x1a, 0xe1, 0x92, 0x21, 0xdf, 0x67, 0x47, 0x7c, 0x7f, 0x05, 0x40, 0x3c, 0x64, 0xee, 0x73, 0xe2,
	0xa8, 0x40, 0x8b, 0xe5, 0xcf, 0xf8, 0x44, 0x52, 0x68, 0xf2, 0x09, 0x75, 0xea, 0x87, 0x08, 0x4a,
	0x87, 0x96, 0x17, 0x42, 0xb8, 0x0f, 0x05, 0x9e, 0x50, 0xbe, 0xeb, 0x32, 0x95, 0x91, 0x53, 0xd8,
	0x6a, 0xb8, 0x2e, 0x33, 0xf2, 0x1d, 0xf9, 0x27, 0x10, 0x9f, 0xb3, 0x7e, 0xe7, 0x65, 0x7a, 0x9d,
	0x68, 0xff, 0x46, 0x70, 0x39, 0x26, 0x46, 0x8a, 0x24, 0xfb, 0xb0, 0xdc, 0xb6, 0x18, 0xdf, 0xdf,
	0xdb, 0x6e, 0x73, 0x56, 0x88, 0x07, 0x6e, 0x53, 0x40, 0x5c, 0x94, 0xa2, 0x6a, 0x88, 0x9f, 0xc8,
	0xed, 0x33, 0x88, 0x06, 0x55, 0x05, 0xe3, 0xfa, 0x14, 0x63, 0x83, 0x0a, 0xc4, 0xb7, 0xd2, 0x10,
	0x20, 0xbe, 0x0e, 0xcb, 0x82, 0x79, 0x91, 0xf8, 0xa4, 0x45, 0x7c, 0x16, 0xf9, 0xf4, 0xd3, 0x20,
	0x46, 0xda, 0xcf, 0x53, 0x70, 0x45, 0x94, 0x9d, 0xcf, 0xc2, 0xc3, 0x84, 0xbd, 0xea, 0xff, 0x9a,
	0x89, 0xbf, 0x4f, 0x41, 0x59, 0x38, 0xe7, 0x1c, 0xe9, 0xc8, 0x92, 0xb7, 0x87, 0xed, 0x69, 0xdb,
	0x43, 0x04, 0xca, 0xff, 0xe4, 0xd6, 0xf0, 0x67, 0x04, 0x57, 0x27, 0x11, 0xea, 0x73, 0x48, 0x9a,
	0xa7, 0xf1, 0x49, 0xf3, 0xd6, 0x1c, 0x6e, 0x1c, 0xce, 0x1c, 0xed, 0xa7, 0x08, 0xb0, 0x6c, 0xf7,
	0xa4, 0x37, 0x27, 0xa4, 0x41, 0x76, 0x3c, 0x0d, 0xf6, 0x38, 0x89, 0x99, 0xdf, 0x37, 0xbb, 0x42,
	0x5c, 0x90, 0x38, 0x39, 0x7f, 0x23, 0xbd, 0x25, 0x27, 0x7b, 0x38, 0x18, 0x69, 0x9f, 0xd2, 0xe5,
	0x8c, 0xf6, 0x31, 0x82, 0x35, 0x81, 0xfc, 0x83, 0x2e, 0xe9, 0x12, 0xee, 0x58, 0x25, 0x37, 0x7b,
	0x9a, 0xbe, 0x07, 0x79, 0x89, 0x6c, 0x96, 0xd2, 0x12, 0x85, 0x16, 0x88, 0xf1, 0xf3, 0x2c, 0x7e,
	0x44, 0xc2, 0xb4, 0x9d, 0xc3, 0x37, 0xd5, 0x91, 0x63, 0x55, 0x3a, 0x72, 0x62, 0x4a, 0xc8, 0xce,
	0x54, 0x42, 0x76, 0x32, 0xa8, 0x3c, 0x22, 0xec, 0x40, 0xd0, 0x61, 0x1a, 0xa2, 0x18, 0x6f, 0x9c,
	0xf1, 0xad, 0xc7, 0xa2, 0x19, 0x12, 0xdc, 0xdb, 0x18, 0xab, 0x04, 0x97, 0x06, 0xad, 0x8e, 0xec,
	0x2e, 0xc7, 0xd2, 0xff, 0x4d, 0x58, 0xe4, 0xa4, 0x8f, 0xf6, 0x48, 0xbc, 0xaf, 0x5d, 0x68, 0xbb,
	0xcd, 0xb0, 0x0f, 0xd2, 0xf6, 0x61, 0x29, 0xa0, 0xbb, 0xb2, 0x67, 0x0d, 0x8a, 0xfc, 0x35, 0x66,
	0xcb, 0xa2, 0xad, 0xa0, 0xef, 0xe2, 0x13, 0x8f, 0x2d, 0xda, 0xe2, 0x0f, 0x47, 0xb1, 0x17, 0x58,
	0x80, 0xf7, 0x04, 0xf2, 0x41, 0xae, 0x6c, 0x40, 0x61, 0x24, 0xe1, 0xc6, 0xf0, 0x06, 0xaf, 0xcd,
	0xb7, 0x95, 0xcc, 0x57, 0x60, 0x99, 0xcb, 0xd4, 0x5d, 0x87, 0xda, 0x94, 0x71, 0x72, 0x28, 0xc4,
	0x4b, 0x6d, 0xb7, 0xb9, 0x33, 0x98, 0xd5, 0xfe, 0x81, 0xa0, 0x10, 0x2d, 0xe7, 0xd3, 0xdc, 0x1f,
	0x2d, 0xa3, 0xd9, 0xf9, 0xcb, 0x68, 0x4c, 0x0d, 0xc9, 0x9d, 0xb1, 0x86, 0x44, 0xd3, 0x4c, 0x9d,
	0x0b, 0x7f, 0x82, 0x60, 0x95, 0xd7, 0xaf, 0xe0, 0x7a, 0x81, 0x9e, 0x13, 0xd3, 0x87, 0xb7, 0xa9,
	0xf4, 0xe8, 0x36, 0x35, 0xb4, 0xc5, 0x65, 0x86, 0xb7, 0x38, 0xed, 0xfb, 0x08, 0xde, 0x18, 0xc1,
	0xa4, 0xea, 0xe9, 0x2e, 0x14, 0x83, 0xeb, 0x0b, 0x5a, 0xc9, 0x89, 0xcc, 0xbe, 0x91, 0xe4, 0xcb,
	0xe8, 0x9d, 0x89, 0x31, 0x10, 0x8d, 0x3b, 0x33, 0xe4, 0x63, 0xce, 0x0c, 0x1b, 0x7f, 0xbd, 0x00,
	0xcb, 0x4f, 0x48, 0xff, 0x59, 0x44, 0x2f, 0xfe, 0x11, 0x82, 0x85, 0x47, 0x84, 0xbd, 0x1f, 0x38,
	0x02, 0xd7, 0x92, 0x8f, 0xcb, 0xe1, 0x42, 0xe5, 0xd9, 0x6a, 0x52, 0xa3, 0x1f, 0x2e, 0xd6, 0xae,
	0x7f, 0xfc, 0xaf, 0xff, 0x7c, 0x92, 0xba, 0x86, 0xaf, 0xea, 0xbd, 0x75, 0x3d, 0xf0, 0xba, 0x4d,
	0xa8, 0xfe, 0x2a, 0x1a, 0x96, 0xd7, 0xf8, 0x17, 0x08, 0x4a, 0x91, 0x42, 0x85, 0xdf, 0x4e, 0x46,
	0x33, 0x52, 0x3e, 0xaa, 0xb3, 0xb4, 0x7c, 0xda, 0xd7, 0x04, 0x96, 0x3b, 0xf8, 0x76, 0x32, 0x16,
	0x3d, 0xdc, 0x9b, 0xf4, 0x57, 0xc1, 0xdf, 0xd7, 0xf8, 0xd7, 0x08, 0x56, 0xc6, 0xaa, 0x17, 0xbe,
	0x9d, 0x0c, 0x33, 0xb6, 0xd6, 0xcd, 0x06, 0xf6, 0x5d, 0x01, 0x76, 0x1d, 0xeb, 0xb3, 0x82, 0xdd,
	0x92, 0x39, 0x82, 0x7f, 0x29, 0x81, 0x06, 0x8a, 0x8e, 0x98, 0x4f, 0xac, 0xce, 0xe7, 0xe2, 0xcf,
	0xf9, 0x21, 0x52, 0x01, 0xe6, 0x16, 0xc2, 0x7f, 0x44, 0xb0, 0x38, 0x94, 0x1b, 0x58, 0x4f, 0x2a,
	0x03, 0x31, 0x99, 0x5d, 0xbd, 0x35, 0xbb, 0x80, 0x4c, 0x3b, 0xed, 0xa1, 0xc0, 0xfb, 0x00, 0xdf,
	0x3f, 0x43, 0xfc, 0xf5, 0x41, 0xd6, 0xfd, 0x05, 0xc1, 0x85, 0xa1, 0x17, 0x28, 0x17, 0xcf, 0x6d,
	0xc1, 0xcc, 0x39, 0xaf, 0x1d, 0x08, 0xe4, 0xbb, 0xf8, 0xfd, 0xcf, 0x84, 0x7c, 0xe0, 0xfe, 0x9f,
	0x21, 0xc8, 0xab, 0x16, 0x18, 0x7f, 0x75, 0x96, 0x36, 0x59, 0x02, 0x9e, 0xa3, 0xa3, 0xd6, 0xee,
	0x0a, 0xc8, 0xb7, 0x70, 0x6d, 0x0a, 0x64, 0x7e, 0x9a, 0xa6, 0xfa, 0x2b, 0x75, 0xa8, 0x16, 0x79,
	0xb6, 0x10, 0xbd, 0x56, 0x49, 0xac, 0x4b, 0x31, 0x57, 0x75, 0x55, 0x7d, 0xce, 0xfb, 0x1a, 0xed,
	0x8e, 0x40, 0xaa, 0xe3, 0xb7, 0x67, 0x41, 0xba, 0x75, 0xac, 0x54, 0xe0, 0x3f, 0x21, 0x58, 0x19,
	0xbb, 0xfd, 0x4a, 0x2c, 0x08, 0x93, 0x2e, 0xf3, 0xaa, 0xef, 0x9c, 0xe5, 0x82, 0x4d, 0xdb, 0x12,
	0xb8, 0xdf, 0xc1, 0x1b, 0x73, 0xe1, 0x96, 0x30, 0x3f, 0x45, 0x50, 0x1e, 0xbd, 0x48, 0xc1, 0x1b,
	0x53, 0x08, 0x1c, 0x73, 0x79, 0x54, 0xbd, 0x3d, 0x97, 0x8c, 0x42, 0xfe, 0x0d, 0x81, 0x7c, 0x13,
	0xdf, 0x9d, 0x8f, 0x1b, 0x7a, 0x4b, 0x01, 0xfd, 0x1b, 0x82, 0x95, 0xb1, 0x6e, 0x05, 0x4f, 0x83,
	0x12, 0xd7, 0x2c, 0x27, 0xba, 0x7e, 0x62, 0x43, 0xa4, 0xed, 0x08, 0x03, 0xee, 0x6b, 0x9b, 0x73,
	0x1a, 0x30, 0xa8, 0x84, 0xe8, 0x26, 0xfe, 0x27, 0x82, 0x8b, 0xf1, 0x8d, 0x17, 0xde, 0x9c, 0x46,
	0x88, 0x89, 0xf6, 0xdc, 0x3b, 0x83, 0xa4, 0x32, 0x6a, 0x5b, 0x18, 0xf5, 0x75, 0xed, 0xdd, 0xd9,
	0xf9, 0xc4, 0x95, 0x19, 0x51, 0x9b, 0xfe, 0x80, 0xa0, 0x2c, 0xfa, 0x9d, 0xe8, 0x47, 0xb8, 0xa4,
	0xbd, 0x67, 0xbc, 0x71, 0xab, 0x5e, 0x0c, 0x96, 0x07, 0x1f, 0x13, 0x6b, 0x0f, 0x3b, 0x1e, 0xeb,
	0x6b, 0xdf, 0x11, 0xf8, 0x3e, 0xd0, 0xbe, 0x39, 0x9b, 0xd3, 0xa3, 0x9d, 0x5d, 0x2d, 0x88, 0xc0,
	0xd6, 0x29, 0x07, 0xb7, 0x35, 0xd4, 0xf6, 0xf1, 0x1d, 0x73, 0x35, 0xae, 0x53, 0xc3, 0x77, 0xa7,
	0x39, 0x33, 0xbe, 0xb5, 0x9b, 0x68, 0x81, 0xca, 0x58, 0x6d, 0xca, 0x86, 0x29, 0x7d, 0x2b, 0x75,
	0x0b, 0xbd, 0x5b, 0xe8, 0xe6, 0xf6, 0xe3, 0xef, 0xee, 0x36, 0x6d, 0xd6, 0xea, 0x1e, 0xd7, 0xea,
	0x6e, 0x47, 0x57, 0x9f, 0x5b, 0x47, 0x70, 0xe9, 0x75, 0xd7, 0x97, 0x5f, 0x68, 0xc7, 0xbf, 0xf0,
	0x9a, 0x4d, 0xd7, 0x94, 0x70, 0x72, 0xe2, 0xe7, 0xf6, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x68,
	0xf6, 0x8b, 0xc5, 0x07, 0x1e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KeyTransparencyClient is the client API for KeyTransparency service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KeyTransparencyClient interface {
	// GetDirectory returns the information needed to verify the specified
	// directory.
	GetDirectory(ctx context.Context, in *GetDirectoryRequest, opts ...grpc.CallOption) (*Directory, error)
	// GetRevision returns a SignedMapRoot by the by the requested revision number
	// along with its inclusion proof in the log and the log's consistency proofs.
	GetRevision(ctx context.Context, in *GetRevisionRequest, opts ...grpc.CallOption) (*Revision, error)
	// GetLatestRevision returns the latest SignedMapRoot along with its inclusion
	// proof in the log and the log's consistency proofs.
	GetLatestRevision(ctx context.Context, in *GetLatestRevisionRequest, opts ...grpc.CallOption) (*Revision, error)
	// GetRevisionStream streams new revisions from a requested starting point
	// and continues as new revisions are created.
	GetRevisionStream(ctx context.Context, in *GetRevisionRequest, opts ...grpc.CallOption) (KeyTransparency_GetRevisionStreamClient, error)
	// ListMutations returns a list of mutations in a specific revision.
	ListMutations(ctx context.Context, in *ListMutationsRequest, opts ...grpc.CallOption) (*ListMutationsResponse, error)
	// ListMutationsStream is a streaming list of mutations in a specific revision.
	ListMutationsStream(ctx context.Context, in *ListMutationsRequest, opts ...grpc.CallOption) (KeyTransparency_ListMutationsStreamClient, error)
	// GetUser returns a user's leaf entry in the Merkle Tree.
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
	// BatchGetUser returns a batch of user leaf entries in the Merkle tree at the same revision.
	BatchGetUser(ctx context.Context, in *BatchGetUserRequest, opts ...grpc.CallOption) (*BatchGetUserResponse, error)
	// BatchGetUserIndex returns the VRF proof for a set of userIDs.
	BatchGetUserIndex(ctx context.Context, in *BatchGetUserIndexRequest, opts ...grpc.CallOption) (*BatchGetUserIndexResponse, error)
	// ListEntryHistory returns a list of historic GetUser values.
	//
	// Clients verify their account history by observing correct values for their
	// account over time.
	ListEntryHistory(ctx context.Context, in *ListEntryHistoryRequest, opts ...grpc.CallOption) (*ListEntryHistoryResponse, error)
	// ListUserRevisions returns a list of historic leaf values for a user.
	//
	// Clients verify their account history by observing correct values for their
	// account over time.
	ListUserRevisions(ctx context.Context, in *ListUserRevisionsRequest, opts ...grpc.CallOption) (*ListUserRevisionsResponse, error)
	// BatchListUserRevisions returns a list of revisions for multiple users.
	BatchListUserRevisions(ctx context.Context, in *BatchListUserRevisionsRequest, opts ...grpc.CallOption) (*BatchListUserRevisionsResponse, error)
	// QueueUserUpdate enqueues an update to a user's profile.
	//
	// Clients should poll GetUser until the update appears, and retry if no
	// update appears after a timeout.
	QueueEntryUpdate(ctx context.Context, in *UpdateEntryRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// BatchQueueUserUpdate enqueues a list of user profiles.
	BatchQueueUserUpdate(ctx context.Context, in *BatchQueueUserUpdateRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type keyTransparencyClient struct {
	cc *grpc.ClientConn
}

func NewKeyTransparencyClient(cc *grpc.ClientConn) KeyTransparencyClient {
	return &keyTransparencyClient{cc}
}

func (c *keyTransparencyClient) GetDirectory(ctx context.Context, in *GetDirectoryRequest, opts ...grpc.CallOption) (*Directory, error) {
	out := new(Directory)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/GetDirectory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) GetRevision(ctx context.Context, in *GetRevisionRequest, opts ...grpc.CallOption) (*Revision, error) {
	out := new(Revision)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/GetRevision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) GetLatestRevision(ctx context.Context, in *GetLatestRevisionRequest, opts ...grpc.CallOption) (*Revision, error) {
	out := new(Revision)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/GetLatestRevision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) GetRevisionStream(ctx context.Context, in *GetRevisionRequest, opts ...grpc.CallOption) (KeyTransparency_GetRevisionStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_KeyTransparency_serviceDesc.Streams[0], "/google.keytransparency.v1.KeyTransparency/GetRevisionStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &keyTransparencyGetRevisionStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KeyTransparency_GetRevisionStreamClient interface {
	Recv() (*Revision, error)
	grpc.ClientStream
}

type keyTransparencyGetRevisionStreamClient struct {
	grpc.ClientStream
}

func (x *keyTransparencyGetRevisionStreamClient) Recv() (*Revision, error) {
	m := new(Revision)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keyTransparencyClient) ListMutations(ctx context.Context, in *ListMutationsRequest, opts ...grpc.CallOption) (*ListMutationsResponse, error) {
	out := new(ListMutationsResponse)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/ListMutations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) ListMutationsStream(ctx context.Context, in *ListMutationsRequest, opts ...grpc.CallOption) (KeyTransparency_ListMutationsStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_KeyTransparency_serviceDesc.Streams[1], "/google.keytransparency.v1.KeyTransparency/ListMutationsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &keyTransparencyListMutationsStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KeyTransparency_ListMutationsStreamClient interface {
	Recv() (*MutationProof, error)
	grpc.ClientStream
}

type keyTransparencyListMutationsStreamClient struct {
	grpc.ClientStream
}

func (x *keyTransparencyListMutationsStreamClient) Recv() (*MutationProof, error) {
	m := new(MutationProof)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keyTransparencyClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) BatchGetUser(ctx context.Context, in *BatchGetUserRequest, opts ...grpc.CallOption) (*BatchGetUserResponse, error) {
	out := new(BatchGetUserResponse)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/BatchGetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) BatchGetUserIndex(ctx context.Context, in *BatchGetUserIndexRequest, opts ...grpc.CallOption) (*BatchGetUserIndexResponse, error) {
	out := new(BatchGetUserIndexResponse)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/BatchGetUserIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) ListEntryHistory(ctx context.Context, in *ListEntryHistoryRequest, opts ...grpc.CallOption) (*ListEntryHistoryResponse, error) {
	out := new(ListEntryHistoryResponse)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/ListEntryHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) ListUserRevisions(ctx context.Context, in *ListUserRevisionsRequest, opts ...grpc.CallOption) (*ListUserRevisionsResponse, error) {
	out := new(ListUserRevisionsResponse)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/ListUserRevisions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) BatchListUserRevisions(ctx context.Context, in *BatchListUserRevisionsRequest, opts ...grpc.CallOption) (*BatchListUserRevisionsResponse, error) {
	out := new(BatchListUserRevisionsResponse)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/BatchListUserRevisions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) QueueEntryUpdate(ctx context.Context, in *UpdateEntryRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/QueueEntryUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyTransparencyClient) BatchQueueUserUpdate(ctx context.Context, in *BatchQueueUserUpdateRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/google.keytransparency.v1.KeyTransparency/BatchQueueUserUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeyTransparencyServer is the server API for KeyTransparency service.
type KeyTransparencyServer interface {
	// GetDirectory returns the information needed to verify the specified
	// directory.
	GetDirectory(context.Context, *GetDirectoryRequest) (*Directory, error)
	// GetRevision returns a SignedMapRoot by the by the requested revision number
	// along with its inclusion proof in the log and the log's consistency proofs.
	GetRevision(context.Context, *GetRevisionRequest) (*Revision, error)
	// GetLatestRevision returns the latest SignedMapRoot along with its inclusion
	// proof in the log and the log's consistency proofs.
	GetLatestRevision(context.Context, *GetLatestRevisionRequest) (*Revision, error)
	// GetRevisionStream streams new revisions from a requested starting point
	// and continues as new revisions are created.
	GetRevisionStream(*GetRevisionRequest, KeyTransparency_GetRevisionStreamServer) error
	// ListMutations returns a list of mutations in a specific revision.
	ListMutations(context.Context, *ListMutationsRequest) (*ListMutationsResponse, error)
	// ListMutationsStream is a streaming list of mutations in a specific revision.
	ListMutationsStream(*ListMutationsRequest, KeyTransparency_ListMutationsStreamServer) error
	// GetUser returns a user's leaf entry in the Merkle Tree.
	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
	// BatchGetUser returns a batch of user leaf entries in the Merkle tree at the same revision.
	BatchGetUser(context.Context, *BatchGetUserRequest) (*BatchGetUserResponse, error)
	// BatchGetUserIndex returns the VRF proof for a set of userIDs.
	BatchGetUserIndex(context.Context, *BatchGetUserIndexRequest) (*BatchGetUserIndexResponse, error)
	// ListEntryHistory returns a list of historic GetUser values.
	//
	// Clients verify their account history by observing correct values for their
	// account over time.
	ListEntryHistory(context.Context, *ListEntryHistoryRequest) (*ListEntryHistoryResponse, error)
	// ListUserRevisions returns a list of historic leaf values for a user.
	//
	// Clients verify their account history by observing correct values for their
	// account over time.
	ListUserRevisions(context.Context, *ListUserRevisionsRequest) (*ListUserRevisionsResponse, error)
	// BatchListUserRevisions returns a list of revisions for multiple users.
	BatchListUserRevisions(context.Context, *BatchListUserRevisionsRequest) (*BatchListUserRevisionsResponse, error)
	// QueueUserUpdate enqueues an update to a user's profile.
	//
	// Clients should poll GetUser until the update appears, and retry if no
	// update appears after a timeout.
	QueueEntryUpdate(context.Context, *UpdateEntryRequest) (*empty.Empty, error)
	// BatchQueueUserUpdate enqueues a list of user profiles.
	BatchQueueUserUpdate(context.Context, *BatchQueueUserUpdateRequest) (*empty.Empty, error)
}

// UnimplementedKeyTransparencyServer can be embedded to have forward compatible implementations.
type UnimplementedKeyTransparencyServer struct {
}

func (*UnimplementedKeyTransparencyServer) GetDirectory(ctx context.Context, req *GetDirectoryRequest) (*Directory, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDirectory not implemented")
}
func (*UnimplementedKeyTransparencyServer) GetRevision(ctx context.Context, req *GetRevisionRequest) (*Revision, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRevision not implemented")
}
func (*UnimplementedKeyTransparencyServer) GetLatestRevision(ctx context.Context, req *GetLatestRevisionRequest) (*Revision, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestRevision not implemented")
}
func (*UnimplementedKeyTransparencyServer) GetRevisionStream(req *GetRevisionRequest, srv KeyTransparency_GetRevisionStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRevisionStream not implemented")
}
func (*UnimplementedKeyTransparencyServer) ListMutations(ctx context.Context, req *ListMutationsRequest) (*ListMutationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMutations not implemented")
}
func (*UnimplementedKeyTransparencyServer) ListMutationsStream(req *ListMutationsRequest, srv KeyTransparency_ListMutationsStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ListMutationsStream not implemented")
}
func (*UnimplementedKeyTransparencyServer) GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (*UnimplementedKeyTransparencyServer) BatchGetUser(ctx context.Context, req *BatchGetUserRequest) (*BatchGetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetUser not implemented")
}
func (*UnimplementedKeyTransparencyServer) BatchGetUserIndex(ctx context.Context, req *BatchGetUserIndexRequest) (*BatchGetUserIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetUserIndex not implemented")
}
func (*UnimplementedKeyTransparencyServer) ListEntryHistory(ctx context.Context, req *ListEntryHistoryRequest) (*ListEntryHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEntryHistory not implemented")
}
func (*UnimplementedKeyTransparencyServer) ListUserRevisions(ctx context.Context, req *ListUserRevisionsRequest) (*ListUserRevisionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserRevisions not implemented")
}
func (*UnimplementedKeyTransparencyServer) BatchListUserRevisions(ctx context.Context, req *BatchListUserRevisionsRequest) (*BatchListUserRevisionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchListUserRevisions not implemented")
}
func (*UnimplementedKeyTransparencyServer) QueueEntryUpdate(ctx context.Context, req *UpdateEntryRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueueEntryUpdate not implemented")
}
func (*UnimplementedKeyTransparencyServer) BatchQueueUserUpdate(ctx context.Context, req *BatchQueueUserUpdateRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchQueueUserUpdate not implemented")
}

func RegisterKeyTransparencyServer(s *grpc.Server, srv KeyTransparencyServer) {
	s.RegisterService(&_KeyTransparency_serviceDesc, srv)
}

func _KeyTransparency_GetDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).GetDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/GetDirectory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).GetDirectory(ctx, req.(*GetDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_GetRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRevisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).GetRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/GetRevision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).GetRevision(ctx, req.(*GetRevisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_GetLatestRevision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestRevisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).GetLatestRevision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/GetLatestRevision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).GetLatestRevision(ctx, req.(*GetLatestRevisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_GetRevisionStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRevisionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KeyTransparencyServer).GetRevisionStream(m, &keyTransparencyGetRevisionStreamServer{stream})
}

type KeyTransparency_GetRevisionStreamServer interface {
	Send(*Revision) error
	grpc.ServerStream
}

type keyTransparencyGetRevisionStreamServer struct {
	grpc.ServerStream
}

func (x *keyTransparencyGetRevisionStreamServer) Send(m *Revision) error {
	return x.ServerStream.SendMsg(m)
}

func _KeyTransparency_ListMutations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMutationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).ListMutations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/ListMutations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).ListMutations(ctx, req.(*ListMutationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_ListMutationsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListMutationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KeyTransparencyServer).ListMutationsStream(m, &keyTransparencyListMutationsStreamServer{stream})
}

type KeyTransparency_ListMutationsStreamServer interface {
	Send(*MutationProof) error
	grpc.ServerStream
}

type keyTransparencyListMutationsStreamServer struct {
	grpc.ServerStream
}

func (x *keyTransparencyListMutationsStreamServer) Send(m *MutationProof) error {
	return x.ServerStream.SendMsg(m)
}

func _KeyTransparency_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_BatchGetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).BatchGetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/BatchGetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).BatchGetUser(ctx, req.(*BatchGetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_BatchGetUserIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetUserIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).BatchGetUserIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/BatchGetUserIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).BatchGetUserIndex(ctx, req.(*BatchGetUserIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_ListEntryHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEntryHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).ListEntryHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/ListEntryHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).ListEntryHistory(ctx, req.(*ListEntryHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_ListUserRevisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserRevisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).ListUserRevisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/ListUserRevisions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).ListUserRevisions(ctx, req.(*ListUserRevisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_BatchListUserRevisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchListUserRevisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).BatchListUserRevisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/BatchListUserRevisions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).BatchListUserRevisions(ctx, req.(*BatchListUserRevisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_QueueEntryUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).QueueEntryUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/QueueEntryUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).QueueEntryUpdate(ctx, req.(*UpdateEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyTransparency_BatchQueueUserUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchQueueUserUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyTransparencyServer).BatchQueueUserUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.keytransparency.v1.KeyTransparency/BatchQueueUserUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyTransparencyServer).BatchQueueUserUpdate(ctx, req.(*BatchQueueUserUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _KeyTransparency_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.keytransparency.v1.KeyTransparency",
	HandlerType: (*KeyTransparencyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDirectory",
			Handler:    _KeyTransparency_GetDirectory_Handler,
		},
		{
			MethodName: "GetRevision",
			Handler:    _KeyTransparency_GetRevision_Handler,
		},
		{
			MethodName: "GetLatestRevision",
			Handler:    _KeyTransparency_GetLatestRevision_Handler,
		},
		{
			MethodName: "ListMutations",
			Handler:    _KeyTransparency_ListMutations_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _KeyTransparency_GetUser_Handler,
		},
		{
			MethodName: "BatchGetUser",
			Handler:    _KeyTransparency_BatchGetUser_Handler,
		},
		{
			MethodName: "BatchGetUserIndex",
			Handler:    _KeyTransparency_BatchGetUserIndex_Handler,
		},
		{
			MethodName: "ListEntryHistory",
			Handler:    _KeyTransparency_ListEntryHistory_Handler,
		},
		{
			MethodName: "ListUserRevisions",
			Handler:    _KeyTransparency_ListUserRevisions_Handler,
		},
		{
			MethodName: "BatchListUserRevisions",
			Handler:    _KeyTransparency_BatchListUserRevisions_Handler,
		},
		{
			MethodName: "QueueEntryUpdate",
			Handler:    _KeyTransparency_QueueEntryUpdate_Handler,
		},
		{
			MethodName: "BatchQueueUserUpdate",
			Handler:    _KeyTransparency_BatchQueueUserUpdate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetRevisionStream",
			Handler:       _KeyTransparency_GetRevisionStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListMutationsStream",
			Handler:       _KeyTransparency_ListMutationsStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "v1/keytransparency.proto",
}
